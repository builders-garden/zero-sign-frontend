{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":1017531816246903168,"abi":{"parameters":[{"name":"message_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"operation_signature","type":{"kind":"array","length":65,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"identity_verification_signature","type":{"kind":"array","length":65,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"identity_pub_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"identity_pub_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"operation_pub_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"operation_pub_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signers_identifiers","type":{"kind":"array","length":96,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"threshold","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"contract_address","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"H4sIAAAAAAAA/+1dDZxV09eeuXfm3r6jTxUhKSq5d/qYSqIQQgihEtWp9K1vkpAUqSgVSiF9EEIIoUhCJSRFEn0IRZGEUO/e//bRmW05M3Wede7eb3Pe3/p37tq9e9ZZ61nPfda+o5uetv+qUCAt7fUi++/ThUXVn/IqoPnSCV+E8EUJXwbhyyR8McIXJ3wFCF9BwleI8BUmfEUIX1HCV4zwFSd8RxC+IwlfCcJXkvCVInylCV8ZwleW8B1F+MoRvvKErwLhO5rwHUP4KhK+YwnfcYTveMJXifCdQPgqE74TCV8VwleV8J1E+E4mfNUIX3XCV4PwnUL4ahK+UwlfgvAlCV8W4atF+GoTvjqEry7hyyZ89QhffcLXgPCdRvgaEr7TCV8jwncG4TuT8DUmfE0I31mE72zCdw7ha0r4ziV85xG+8wlfM8J3AeG7kPBdRPiaE76LCd8lhO9SwteC8F1G+C4nfFcQvpaE70rCdxXhu5rwtSJ8rQlfG8J3DeFrS/iuJXzXEb52hK894etA+BzC15HwdSJ8nQnf9YSvC+HrSvi6Eb7uhK8H4etJ+HoRvhsIX2/C14fw9SV8/Qhff8I3gPANJHw3Er6bCN8gwncz4RtM+G4hfEMI362E7zbCdzvhG0r47iB8wwjfnYRvOOEbQfjuInx3E76RhO8ewjeK8I0mfGMI372E7z7CN5bwjSN89xO+8YRvAuGbSPgeIHwPEr6HCN8kwjeZ8D1M+KYQvqmE7xHC9yjhe4zwTSN8jxO+6YRvBuGbSfhmEb4nCN+ThG824XuK8D1N+J4hfHMI37OE7znC9zzhm0v4XiB8LxK+lwjfPML3MuF7hfC9SvjmE77XCN/rhO8NwreA8C0kfG8SvrcI3yLC9zbhW0z43iF8Swjfu4TvPcL3PuFbSviWEb7lhO8DwreC8H1I+D4ifB8TvpWE7xPCt4rwfUr4VhO+NYTvM8L3OeFbS/i+IHzrCN+XhG894fuK8H1N+DYQvo2EbxPh20z4viF8Wwjft4TvO8L3PeHbSvi2Eb4fCN+PhG874dtB+H4ifD8Tvp2E7xfCt4vw/Ur4dhO+3wjf74TvD8K3h/D9Sfj+Inx/E769hG8f4ZP/o/vSCV+E8EUJXwbhyyR8McIXJ3wFCF9BwleI8BUmfEUIX1HCV4zwFSd8RxC+IwlfCcJXkvCVInylCV8ZwleW8B1F+MoRvvKErwLhO5rwHUP4KhK+YwnfcYTveMJXifCdQPgqE74TCV8VwleV8J1E+E4mfNUIX3XCV4PwnUL4ahK+UwlfgvAlCV8W4atF+GoTvjqEry7hyyZ89QhffcLXgPCdRvgaEr7TCV8jwncG4TuT8DUmfE0I31mE72zCdw7ha0r4ziV85xG+8wlfM8J3AeG7kPBdRPiaE76LCd8lhO9SwteC8F1G+C4nfFcQvpaE70rCdxXhu5rwtSJ8rQlfG8J3DeFrS/iuJXzXEb52hK894etA+BzC15HwdSJ8nQnf9YSvC+HrSvi6Eb7uhK8H4etJ+HoRvhsIX2/C14fw9SV8/Qhff8I3gPANJHw3Er6bCN8gwncz4RtM+G4hfEMI362E7zbCdzvhGyr+5zjNdwfx94YRvjsJ33DCN4Lw3UX47iZ8IwnfPYRvFOEbTfjGEL57Cd99hG8s4RtH+O4nfOMJ3wTCN1H55Oft8oqk/ftKV3+eqf5MBLuSst6gvRJEuKC9kwlvLiarJDycriVQLmRovofTDyTUvaKMSayVqFu7dsfsrI7JWsl2iaz67evVSdSu075uvWS9ZJ16dZyserVqdaxXu152/fb1sxP1k7VrdUx2qlO/VsdO/7uSkwF7dVKBPQwsbj4o/xVmDlBOUUmYqoNyCgHKqZaBcgoQlFMtBeVkWNyd6qZxgTKZyAHKR1QSHtVBKRd036Pq7YcTlJNhoEwkHwGC8lFwcXXwBY1P5k0+r7n1cKD1eAxWj1oJL8Yf82CcgyBkDiLQfetkI/M6DUi+3rxOS4F0nZpuHyE/rpIwXSffxwlCnh4CIU8FEvLjQKBON5yQZd4eTze5Hg60HjOYCHkGIyG7NUITMjKvM5kIeWYKCHmYhWPbLJWEJ3TynUWMbU+k849tw4Bj2ywgUJ+wdGyzEZRPqiTM1kH5JAHK2ZaB8kkgKGdbCspZFkrXp1QSntZB+RQhXZ8OQbrOgoEykXwKCMqnDZeuMm9PpZtcDwdaj2eYpOszjNLVrRFauiLzOodJus5JgXSdnW4fIT+rkvCcTr7PEoT8XAiEPBtIyM8Cgfqc4YQs8/Zsusn1cKD1eJ6JkJ9nJGS3RmhCRuZ1LhMhz00BId9p4dj2gkrCizr5vkCMbS+m849tdwLHtheAQH3R0rHNRlC+pJIwTwflSwQo51kGypeAoJxnKShfsFC6vqyS8IoOypcJ6fpKCNL1BRgoE8mXgaB8xXDpKvP2crrJ9XCg9XiVSbq+yihd3RqhpSsyr/OZpOv8FEjXeen2EfJrKgmv6+T7GkHIr4dAyPOAhPwaEKivG07IMm+vpZtcDwdajzeYCPkNRkJ2a4QmZGReFzAR8oIUEPJwC8e2hSoJb+rku5AY295M5x/bhgPHtoVAoL5p6dhmIyjfUklYpIPyLQKUiywD5VtAUC6yFJQLLZSub6skLNZB+TYhXReHIF0XwkCZSL4NBOViw6WrzNvb6SbXw4HW4x0m6foOo3R1a4SWrsi8LmGSrktSIF0XpdtHyO+qJLynk++7BCG/FwIhLwIS8rtAoL5nOCHLvL2bbnI9HGg93mci5PcZCdmtEZqQkXldykTIS1NAyCMsHNuWqSQs18l3GTG2LU/nH9tGAMe2ZUCgLrd0bLMRlB+oJKzQQfkBAcoVloHyAyAoV1gKymUWStcPVRI+0kH5ISFdPwpBui6DgTKR/BAIyo8Ml64ybx+mm1wPB1qPj5mk68eM0tWtEVq6IvO6kkm6rkyBdF2Rbh8hf6KSsEon308IQl4VAiGvABLyJ0CgrjKckGXePkk3uR4OtB6fMhHyp4yE7NYITcjIvK5mIuTVKSDkuywc29aoJHymk+8aYmz7LJ1/bLsLOLatAQL1M0vHNhtB+blKwlodlJ8ToFxrGSg/B4JyraWgXGOhdP1CJWGdDsovCOm6LgTpugYGykTyCyAo1xkuXWXevkg3uR4OtB5fMknXLxmlq1sjtHRF5nU9k3RdnwLpujbdPkL+SiXha518vyII+esQCHktkJC/AgL1a8MJWebtq3ST6+FA67GBiZA3MBKyWyM0ISPzupGJkDemgJDvtnBs26SSsFkn303E2LY5nX9suxs4tm0CAnWzpWObjaD8RiVhiw7KbwhQbrEMlN8AQbnFUlBuslC6fquS8J0Oym8J6fpdCNJ1EwyUieS3QFB+Z7h0lXn7Nt3kejjQenzPJF2/Z5Subo3Q0hWZ161M0nVrCqTrlnT7CHmbSsIPOvluIwj5hxAIeQuQkLcBgfqD4YQs87Yt3eR6ONB6/MhEyD8yErJbIzQhI/O6nYmQt6eAkEdaOLbtUEn4SSffHcTY9lM6/9g2Eji27QAC9SdLxzYbQfmzSsJOHZQ/E6DcaRkofwaCcqeloNxhoXT9RSVhlw7KXwjpuisE6boDBspE8hcgKHcZLl1l3n5JN7keDrQevzJJ118ZpatbI7R0ReZ1N5N03Z0C6boz3T5C/k0l4XedfH8jCPn3EAh5J5CQfwMC9XfDCVnm7bd0k+vhQOvxBxMh/8FIyG6N0ISMzOseJkLekwJCvsfCse1PlYS/dPL9kxjb/krnH9vuAY5tfwKB+pelY5uNoPxbJWGvDsq/CVDutQyUfwNBuddSUP5poXTdl+5JkBeA+wjpKv8St3T9EwbKRHIfEJTy2ZHFRUtXmbd96SbXw4HWIx1Wj5zSNT3CJ13dGqGlKzKvkQiOfL15jUTCl657LSTkqHqRoROyXNAJOSMEQt4LJORoBAfUDMMJWeZNPq+59XCg9chkIuRMRkJ2a4QmZGReY0yEHEsBIY+ycGyLqxcFdEKWC/rYViDCP7aNAo5tcSBQCwCBmg/Kf4WZA5QF1YtCOigLEqAsZBkoCwJBWchSUMbB6oYFlJp0LaxeFNFBWZiQrkVCkK4IdnOla2EgKIsYLl1l3gpHTK6HA61HUSbpWpRRuro1QktXZF6LMUnXYimQroUi9hFycfXiCJ2QixOEfEQIhFwISMjFgUA9wnBClnkrHjG5Hg60HkcyEfKRjITs1ghNyMi8lmAi5BIpIOTRFo5tJdWLUjohlyTGtlIR/rFtNHBsKwkEailLxzYbQVlavSijg7I0AcoyloGyNBCUZSwFZUkLpWtZ9eIoHZRlCel6VAjSFcFurnQtCwTlUYZLV5m3shGT6+FA61GOSbqWY5Subo3Q0hWZ1/JM0rV8CqRrmYh9hFxBvThaJ+QKBCEfHQIhlwEScgUgUI82nJBl3ipETK6HA63HMUyEfAwjIbs1QhMyMq8VmQi5YgoIeYyFY9ux6sVxOiEfS4xtx0X4x7YxwLHtWCBQj7N0bLMRlMerF5V0UB5PgLKSZaA8HgjKSpaC8lgLpesJ6kVlHZQnENK1cgjSFcFurnQ9AQjKyoZLV5m3EyIm18OB1uNEJul6IqN0dWuElq7IvFZhkq5VUiBdK0XsI+Sq6sVJOiFXJQj5pBAIuRKQkKsCgXqS4YQs81Y1YnI9HGg9TmYi5JMZCdmtEZqQkXmtxkTI1VJAyPdaOLZVVy9q6IRcnRjbakT4x7Z7gWNbdSBQa1g6ttkIylPUi5o6KE8hQFnTMlCeAgRlTUtBWd1C6XqqepHQQXkqIV0TIUhXBLu50vVUICgThktXmbdTIybXw4HWI8kkXZOM0tWtEVq6IvOaxSRds1IgXWtG7CPkWupFbZ2QaxGEXDsEQq4JJORaQKDWNpyQZd5qRUyuhwOtRx0mQq7DSMhujdCEjMxrXSZCrpsCQr7PwrEtW72opxNyNjG21Yvwj233Ace2bCBQ61k6ttkIyvrqRQMdlPUJUDawDJT1gaBsYCkosy2UrqepFw11UJ5GSNeGIUhXBLu50vU0ICgbGi5dZd5Oi5hcDwdaj9OZpOvpjNLVrRFauiLz2ohJujZKgXRtELGPkM9QL87UCfkMgpDPDIGQGwAJ+QwgUM80nJBl3s6ImFwPB1qPxkyE3JiRkN0aoQkZmdcmTITcJAWEPNbCse0s9eJsnZDPIsa2syP8Y9tY4Nh2FhCoZ1s6ttkIynPUi6Y6KM8hQNnUMlCeAwRlU0tBeZaF0vVc9eI8HZTnEtL1vBCkK4LdXOl6LhCU5xkuXWXezo2YXA8HWo/zmaTr+YzS1a0RWroi89qMSbo2S4F0bRqxj5AvUC8u1An5AoKQLwyBkJsCCfkCIFAvNJyQZd4uiJhcDwdaj4uYCPkiRkJ2a4QmZGRemzMRcvMUEPI4C8e2i9WLS3RCvpgY2y6J8I9t44Bj28VAoF5i6dhmIygvVS9a6KC8lABlC8tAeSkQlC0sBeXFFkrXy9SLy3VQXkZI18tDkK4IdnOl62VAUF5uuHSVebssYnI9HGg9rmCSrlcwSle3RmjpisxrSybp2jIF0rVFxD5CvlK9uEon5CsJQr4qBEJuASTkK4FAvcpwQpZ5uzJicj0caD2uZiLkqxkJ2a0RmpCReW3FRMitUkDI91s4trVWL9rohNyaGNvaRPjHtvuBY1trIFDbWDq22QjKa9SLtjooryFA2dYyUF4DBGVbS0HZ2kLpeq16cZ0OymsJ6XpdCNIVwW6udL0WCMrrDJeuMm/XRkyuhwOtRzsm6dqOUbq6NUJLV2Re2zNJ1/YpkK5tI/YRcgf1wtEJuQNByE4IhNwWSMgdgEB1DCdkmbcOEZPr4UDr0ZGJkDsyErJbIzQhI/PaiYmQO6WAkMdbOLZ1Vi+u1wm5MzG2XR/hH9vGA8e2zkCgXm/p2GYjKLuoF111UHYhQNnVMlB2AYKyq6Wg7GyhdO2mXnTXQdmNkK7dQ5CuCHZzpWs3ICi7Gy5dZd66RUyuhwOtRw8m6dqDUbq6NUJLV2ReezJJ154pkK5dI/YRci/14gadkHsRhHxDCITcFUjIvYBAvcFwQpZ56xUxuR4OtB69mQi5NyMhuzVCEzIyr32YCLlPCgh5goVjW1/1op9OyH2Jsa1fhH9smwAc2/oCgdrP0rHNRlD2Vy8G6KDsT4BygGWg7A8E5QBLQdnXQuk6UL24UQflQEK63hiCdEWwmytdBwJBeaPh0lXmbWDE5Ho40HrcxCRdb2KUrm6N0NIVmddBTNJ1UAqk64CIfYR8s3oxWCfkmwlCHhwCIQ8AEvLNQKAONpyQZd5ujphcDwdaj1uYCPkWRkJ2a4QmZGRehzAR8pAUEPJEC8e2W9WL23RCvpUY226L8I9tE4Fj261AoN5m6dhmIyhvVy+G6qC8nQDlUMtAeTsQlEMtBeWtFkrXO9SLYToo7yCk67AQpCuC3VzpegcQlMMMl64yb3dETK6HA63HnUzS9U5G6erWCC1dkXkdziRdh6dAug6N2EfII9SLu3RCHkEQ8l0hEPJQICGPAAL1LsMJWeZtRMTkejjQetzNRMh3MxKyWyM0ISPzOpKJkEf6EPIR4DxPFj/wkXQcYU4Vez2ejsuxjG1yOo7nZGxTMc+blP8zS+z1FGK/5P4/Zou9ngU9r9xVxjYLst/+KGVss4M/b9K9eUHs9XLQ/ZIHbueJvV4L/rxZCn9JGdsLQfer/Q+ekzK2ecGeN+l9sVDs9XaQ/ZI5Xy4Se70b7HkTnv5NytgWBtkvKwcfJGVsMkYOHkRyICaurGwUN2dlJxKPg3kPyXnB45JPmEgguHj/TonEs2CeQ3JcsLjcJ0wkgnLvgZ0SidfAvIbktEOPy/uEiUQQrs25UyLxboC9amn/l0Zch7h3Und49ec96sUofQiWCws03yiPQHavEsGC+1ew+cSd5yufuPN+5RN33q/DmrgPUtAmtAE3eQ/wQMLLt4mDvPQ3FPdjT/dgx3uhD+Tu8Yn7YPf2xjs6whjw6DycTh3szxkdgRC9vJJjgMDiyuGYSO4nhwf7c8YAT+U4nnuUeu7csJPbpe+LrPe9TCebct/GaeGcbC4TP/BDoDhcIfb6BHiyKWNbBjzZlLGtAArFNWKvL4Bica3Y6yvgyaaMbQ3wZFPGthYoHDeJvb4FisctYq9twJNNGdsm4MmmjG0LUEjuEHv9AhSTO8VevwFPNmVsO4AnmzK2nek8PIjkQExcWdkobpbi/BMw7yE5L3hc+8cPBBe7g8xXYJ5DclywuA6MakG51zv0bQPzGpLTDj2unGNtEK7VB+TfLDzZvE+9GKufbN5HnGyODeFkM5+483zlE3fer3zizvt1WBN30JPN+4AHEl6+TRzklcqTzfuYTjbHRRgDHsdwsjkuAiF6eSXvN/xkU+bwfoaTzfsNP9kcq547N+zkdun7Ius9nulkc3yIJ5t/ih+4DygO94q9osAcy9j+BJ5sytj2AoViXOxXGIED9aZeSOxVPIJ5XrmrjC0O2W9/lDK2QsGf9x8JU1LsVTbofh5BVEbsVSH48/5zsiljKxl0P8/JpoytTLDnzSH/jhV7nRBkP01MVhJ7VQ32vDlONmVsxwbZTzvZlLHJGDl4EMmBmLiysvcBB+RoBMt7SM4LHtf+8QPBxe4gUxzMc0iOCxbXgVEtKPd6h74KYF5Dctqhx5VzrA3CtfqAXBU4iKYR1yHu7XuyOUG9mCj/9IpWuaCfbE6M8J9s5hN3nq984s77lU/ceb8Oa+IOerI5ATgsTwS+oYR5sjkhwnOy+UCEMeAHIviTzQcwRC+v5INAYHHlUMaIPtl8EJdDlueeqJ47N+zkdun7Iuv9EDCHXkEo9w3rZLO62PxU1HOIN6aaYq9awBzL2KoD9nNPNmVsNYFCMVvsdRpQLDYQe50Bel65q4wtG7Lf/ihlbA2AwvEssde5QPHYVOx1QfDn/edkU8Z2VtD9PCebMramQCF5sdjrMqCYbCH2ujLY8+Y42ZSxXRxkP+1kU8YmY+TgQSQHYuLKykZxsxTntcC8h+S84HHtHz8QXOwOMmeAeQ7JccHiOjCqBeVe79B3AZjXkJx26HHlHGuDcK0+IF8JHETTiOsQ9/Y92ZykXkyWf3pFq1zQTzYnR/hPNvOJO89XPnHn/con7rxfhzVxBz3ZnAQclicD31DCPNmcFOE52Xw4whiw3Dyi7Rs0+IcjuDfGKUBgceVQxog+2ZyCyyHLc09Wz50bdnK79H2R9Z4KzKFXEMp9wzrZbC02vxYoDtuKvToAcyxjaw3Yzz3ZlLG1BQpF94vDA++n3tTd771FPK/cVcaG+aL4/VHK2ABf3v2PhHG/LC3Qfh5B5H7XT8Dn/edkU8YW+MvxPCebMraAX1iWQ/65/0D8Ie+niUn33zcO8Lw5TjZlbIG+EEA72ZSxyRg5eBDJgZi4srJR3CzFeQcw7yE5L3hc+8cPBBe7g0wvMM8hOS5YXAdGtaDc6x36bgbzGpLTDj2unGNtEK7VB+QRwEE0jbgOcW/fk81H1ItH5Z9e0SoX9JPNRyP8J5v5xJ3nK5+4837lE3fer8OauIOebD4CHJYfBb6hhHmy+UiE52TzsQhjwHLziLZv0OAfi+DeGKcBgcWVQxkj+mRzGi6HLM/9qHru3LCT26Xvi6z348AcegWh3Lexui+UlvMfY/f+80Xe/+DH+xG5LipRvQLeL5G/X/5++fsduOqB90PHl7/f4bffdPE+MkPYTGGzhD0h7Elhs4U9JexpYc8ImyPsWWHPCXte2FxhLwh7UdhLwuYJe1nYK8JeFTZf2GvCXo/s/wRPvs+73+jovXLTPQd5JaeDdY9+gfaux7Z3cr/WcHPrfgPkGyIvC4QtFPamsLeELRL2trDFkbScJ1byLxfQfAsI30LC9ybhe4vwLSJ8bxO+xZF/f1VrQWTCNNAEFY1vAPZyP6ZdANpLPuNCyF778/Vm8L3++WjxraB7eT5WXBRsr5xfjRdkL+3jusVAUgqTTGfkkylJpu+IvCwR9q6w94S9L2ypsGXClutk+g5BaksI37uE7z3C9z7hW0r4lhG+5SGQ6Qwgmb4DJNMlQDJ9F0im7wHJ9H0gmS4FkukyIJkut5RMZ+aTKUmmH4i8rBD2obCPhH0sbKWwT4St0sn0A4LUVhC+DwnfR4TvY8K3kvB9QvhWhUCmM4Fk+gGQTFcAyfRDIJl+BCTTj4FkuhJIpp8AyXSVpWQ6K59MSTL9VORltbA1wj4T9rmwtcK+ELZOJ9NPCVJbTfjWEL7PCN/nhG8t4fuC8K0LgUxnAcn0UyCZrgaS6RogmX4GJNPPgWS6FkimXwDJdB2QlGRPxFRvTEs70C+Pe+6ne+5neO5neu5nee6f8Nw/6bmf7bl/ynP/tOf+Gc/9HM/9s5775zz3z3vu53ruX/Dcv+i5f8lzP89z/7Ln/hXP/aue+/me+9c896977t/w3C/w3C/03L/puX/Lc7/Ic/+2536x5/4dz/0Sz/27nvv3PPfve+6Xeu6Xee6Xe+4/8Nyv8Nx/6Ln/yHP/sed+pef+E8/9Ks/9p5771Z77NZ77zzz3n3vu13ruv/Dcr/Pcf+m5X++5/8pz/7XnfoPnvp3nvr3nvoPn3vHcd/Tcd/Lcd/bcX++57+K57+q57+a57+657+G57+m57+W5v8Fz39tz38dz39dz389z399zP8BzP9Bzf6Pn/ibP/SDP/c2e+8Ge+1s890M897d67m/z3N/uuR/qub/Dcz/Mc3+n5364536E5/4uz/3dnvuRnvt7PPejPPejPfdjPPf3eu7v89yP9dyP89zf77kf77mf4Lmf6Ll/wHP/oOf+Ic/9JM/9ZM/9w577KZ77qZ77Rzz3j3ruvR/HeD+G8X784v3Yxftxi/djFu/HK4s9994TSu/JpPdE0nsS6T2B9J48ek8cl3vuvUO7d1j3Dune4dw7lHuHce8Qvspz79WxXv3q1a1everVqV596tWlrh79Uopmz5Wu/jxT/ZkIdiW/BGpS6r+U5Iq7XZoNA1gyx2/tr1cvvtIHIbmQofm+ihz4T0/dK8qYxGBDRKfkeiCQvgKfCqTlg9IbZg5Qfq1ebNBB+TUByg2WgfJrICg3WArK9bC4O9VN4wJlMud/37RRvdikg1IupGu+TeqtMo0RlAh2c49bNgJBuQlcXB18QeOTeZPPa249HGg9NsPqUSvHr2xv9mCcgyBkDiLQfetkI/P6Dfhoy83rNyqvYRLyhoh9hLxFvfhWJ+QtBCF/GwIhbwAS8hYgUL81nJBl3rZETK6HA63Hd0yE/B0jIbs1QhMyMq/fMxHy9ykg5Pa4vUIb27aqF9t0Qt5KjG3bIvxjmzeJQce2rUCgbrN0bLMRlD+oFz/qoPyBAOWPloHyByAof7QUlFstlK7b1YsdOii3E9J1RwjSFcFurnTdDgTlDsOlq8zb9ojJ9XCg9fiJSbr+xChd3RqhpSsyrz8zSdefUyBdf4zYR8g71YtfdELeSRDyLyEQ8o9AQt4JBOovhhOyzNvOiMn1cKD12MVEyLsYCdmtEZqQkXn9lYmQf00BIXfA7RXa2LZbvfhNJ+TdxNj2W4R/bPMmMejYthsI1N8sHdtsBOXv6sUfOih/J0D5h2Wg/B0Iyj8sBeVuC6XrHvXiTx2Uewjp+mcI0hXBbq503QME5Z+GS1eZtz0Rk+vhQOvxF5N0/YtRuro1QktXZF7/ZpKuf6dAuv4RsY+Q96oX+3RC3ksQ8r4QCPkPICHvBQJ1n+GELPO2N2JyPRxoPeSDYp4xJyHLGy5CdmuEJmRkXtOjPIScHg2fkB3cXqGNbRHVwFE3ce6fckEf26JR/rHNm8SgY1skigNqFAjUfFD+K8wcoMxQoMrUQZlBgDLTMlBmAEGZaSkoI1GsuknjAKUmXWMKVHEdlHJBl67xKL90RbCbK11jQFDGwcVFS1eZN/m85tbDgdajAJN0LcAoXd0aoaUrMq8FmaRrwRRI10wLCbmQauDCOiEXIgi5cAiEnAkk5EJAoBY2nJBl3gpFTa6HA61HESZCLsJIyG6N0ISMzGtRJkIumgJC7ojbK7SxrZhq4OI6IRcjxrbiUf6xzZvEoGNbMSBQi1s6ttkIyiMUqI7UQXkEAcojLQPlEUBQHmkpKItZKF1LKFCV1EFZgpCuJUOQrgh2c6VrCSAoSxouXWXeSkRNrocDrUcpJulailG6ujVCS1dkXkszSdfSKZCuR1pIyGVUA5fVCbkMQchlQyDkI4GEXAYI1LKGE7LMW5moyfVwoPU4iomQj2IkZLdGaEJG5rUcEyGXSwEhd8LtFdrYVl41cAWdkMsTY1uFKP/Y5k1i0LGtPBCoFSwd22wE5dEKVMfooDyaAOUxloHyaCAoj7EUlOUtlK4VFaiO1UFZkZCux4YgXRHs5krXikBQHmu4dJV5qxg1uR4OtB7HMUnX4xilq1sjtHRF5vV4Jul6fAqk6zEWEnIl1cAn6IRciSDkE0Ig5GOAhFwJCNQTDCdkmbdKUZPr4UDrUZmJkCszErJbIzQhI/N6IhMhn5gCQu6M2yu0sa2KauCqOiFXIca2qlH+sc2bxKBjWxUgUKtaOrbZCMqTFKhO1kF5EgHKky0D5UlAUJ5sKSirWChdqylQVddBWY2QrtVDkK4IdnOlazUgKKsbLl1l3qpFTa6HA61HDSbpWoNRuro1QktXZF5PYZKup6RAup5sISHXVA18qk7INQlCPjUEQj4ZSMg1gUA91XBClnmrGTW5Hg60HgkmQk4wErJbIzQhI/OaZCLkZAoI+XrcXqGNbVmqgWvphJxFjG21ovxjmzeJQce2LCBQa1k6ttkIytoKVHV0UNYmQFnHMlDWBoKyjqWgzLJQutZVoMrWQVmXkK7ZIUhXBLu50rUuEJTZhktXmbe6UZPr4UDrUY9JutZjlK5ujdDSFZnX+kzStX4KpGsdCwm5gWrg03RCbkAQ8mkhEHIdICE3AAL1NMMJWeatQdTkejjQejRkIuSGjITs1ghNyMi8ns5EyKengJC74PYKbWxrpBr4DJ2QGxFj2xlR/rHNm8SgY1sjIFDPsHRssxGUZypQNdZBeSYBysaWgfJMICgbWwrKRhZK1yYKVGfpoGxCSNezQpCuCHZzpWsTICjPMly6yrw1iZpcDwdaj7OZpOvZjNLVrRFauiLzeg6TdD0nBdK1sYWE3FQ18Lk6ITclCPncEAi5MZCQmwKBeq7hhCzz1jRqcj0caD3OYyLk8xgJ2a0RmpCReT2fiZDPTwEhd8XtFdrY1kw18AU6ITcjxrYLovxjmzeJQce2ZkCgXmDp2GYjKC9UoLpIB+WFBCgvsgyUFwJBeZGloGxmoXRtrkB1sQ7K5oR0vTgE6YpgN1e6NgeC8mLDpavMW/OoyfVwoPW4hEm6XsIoXd0aoaUrMq+XMknXS1MgXS+ykJBbqAa+TCfkFgQhXxYCIV8EJOQWQKBeZjghy7y1iJpcDwdaj8uZCPlyRkJ2a4QmZGRer2Ai5CtSQMjdcHuFNra1VA18pU7ILYmx7coo/9jmTWLQsa0lEKhXWjq22QjKqxSortZBeRUByqstA+VVQFBebSkoW1ooXVspULXWQdmKkK6tQ5CuCHZzpWsrIChbGy5dZd5aRU2uhwOtRxsm6dqGUbq6NUJLV2Rer2GSrtekQLpebSEht1UNfK1OyG0JQr42BEK+GkjIbYFAvdZwQpZ5axs1uR4OtB7XMRHydYyE7NYITcjIvLZjIuR2KSDk7ri9Qhvb2qsG7qATcntibOsQ5R/bvEkMOra1BwK1g6Vjm42gdBSoOuqgdAhQdrQMlA4QlB0tBWV7C6VrJwWqzjooOxHStXMI0hXBbq507QQEZWfDpavMW6eoyfVwoPW4nkm6Xs8oXd0aoaUrMq9dmKRrlxRI144WEnJX1cDddELuShBytxAIuSOQkLsCgdrNcEKWeesaNbkeDrQe3ZkIuTsjIbs1QhMyMq89mAi5RwoIuQdur9DGtp6qgXvphNyTGNt6RfnHNm8Sg45tPYFA7WXp2GYjKG9QoOqtg/IGApS9LQPlDUBQ9rYUlD0tlK59FKj66qDsQ0jXviFIVwS7udK1DxCUfQ2XrjJvfaIm18OB1qMfk3Ttxyhd3RqhpSsyr/2ZpGv/FEjX3hYS8gDVwAN1Qh5AEPLAEAi5N5CQBwCBOtBwQpZ5GxA1uR4OtB43MhHyjYyE7NYITcjIvN7ERMg3pYCQe+L2Cm1sG6Qa+GadkAcRY9vNUf6xzZvEoGPbICBQb7Z1bEuzD5SDFahu0UE5mADlLZaBcjAQlLdYCspBFkrXIQpUt+qgHEJI11tDkK4IdnOl6xAgKG81XLrKvA2JmlwPB1qP25ik622M0tWtEVq6IvN6O5N0vT0F0vUWCwl5qGrgO3RCHkoQ8h0hEPItQEIeCgTqHYYTsszb0KjJ9XCg9RjGRMjDGAnZrRGakJF5vZOJkO9MASH3wu0V2tg2XDXwCJ2QhxNj24go/9jmTWLQsW04EKgjLB3bbATlXQpUd+ugvIsA5d2WgfIuICjvthSUwy2UriMVqO7RQTmSkK73hCBdEezmSteRQFDeY7h0lXkbGTW5Hg60HqOYpOsoRunq1ggtXZF5Hc0kXUenQLrebSEhj1ENfK9OyGMIQr43BEK+G0jIY4BAvddwQpZ5GxM1uR4OtB73MRHyfYyE7NYITcjIvI5lIuSxKSDkG3B7hTa2jVMNfL9OyOOIse3+KP/Y5k1i0LFtHBCo91s6ttkIyvEKVBN0UI4nQDnBMlCOB4JygqWgHGehdJ2oQPWADsqJhHR9IATpimA3V7pOBILyAcOlq8zbxKjJ9XCg9XiQSbo+yChd3RqhpSsyrw8xSdeHUiBdJ1hIyJNUA0/WCXkSQciTQyDkCUBCngQE6mTDCVnmbVLU5Ho40Ho8zETIDzMSslsjNCEj8zqFiZCnpICQe+P2Cm1sm6oa+BGdkKcSY9sjUf6xzZvEoGPbVCBQH7F0bLMRlI8qUD2mg/JRApSPWQbKR4GgfMxSUE61ULpOU6B6XAflNEK6Ph6CdEWwmytdpwFB+bjh0lXmbVrU5Ho40HpMZ5Ku0xmlq1sjtHRF5nUGk3SdkQLp+piFhDxTNfAsnZBnEoQ8KwRCfgxIyDOBQJ1lOCHLvM2MmlwPB1qPJ5gI+QlGQnZrhCZkZF6fZCLkJ1NAyH1we4U2ts1WDfyUTsizibHtqSj/2OZNYtCxbTYQqE9ZOrbZCMqnFaie0UH5NAHKZywD5dNAUD5jKShnWyhd5yhQPauDcg4hXZ8NQboi2M2VrnOAoHzWcOkq8zYnanI9HGg9nmOSrs8xSle3Rmjpiszr80zS9fkUSNdnLCTkuaqBX9AJeS5ByC+EQMjPAAl5LhCoLxhOyDJvc6Mm18OB1uNFJkJ+kZGQ3RqhCRmZ15eYCPmlFBByX9xeoY1t81QDv6wT8jxibHs5yj+2eZMYdGybBwTqy5aObTaC8hUFqld1UL5CgPJVy0D5ChCUr1oKynkWStf5ClSv6aCcT0jX10KQrgh2c6XrfCAoXzNcusq8zY+aXA8HWo/XmaTr64zS1a0RWroi8/oGk3R9IwXS9VULCXmBauCFOiEvIAh5YQiE/CqQkBcAgbrQcEKWeVsQNbkeDrQebzIR8puMhOzWCE3IyLy+xUTIb6WAkPvh9gptbFukGvhtnZAXEWPb21H+sc2bxKBj2yIgUN+2dGyzEZSLFaje0UG5mADlO5aBcjEQlO9YCspFFkrXJQpU7+qgXEJI13dDkK4IdnOl6xIgKN81XLrKvC2JmlwPB1qP95ik63uM0tWtEVq6IvP6PpN0fT8F0vUdCwl5qWrgZTohLyUIeVkIhPwOkJCXAoG6zHBClnlbGjW5Hg60HsuZCHk5IyG7NUITMjKvHzAR8gcpIOT+uL1CG9tWqAb+UCfkFcTY9mGUf2zzJjHo2LYCCNQPLR3bbATlRwpUH+ug/IgA5ceWgfIjICg/thSUKyyUrisVqD7RQbmSkK6fhCBdEezmSteVQFB+Yrh0lXlbGTW5Hg60HquYpOsqRunq1ggtXZF5/ZRJun6aAun6sYWEvFo18BqdkFcThLwmBEL+GEjIq4FAXWM4Icu8rY6aXA8HWo/PmAj5M0ZCdmuEJmRkXj9nIuTPU0DIA3B7hTa2rVUN/IVOyGuJse2LKP/Y5k1i0LFtLRCoX1g6ttkIynUKVF/qoFxHgPJLy0C5DgjKLy0F5VoLpet6BaqvdFCuJ6TrVyFIVwS7udJ1PRCUXxkuXWXe1kdNrocDrcfXTNL1a0bp6tYILV2Red3AJF03pEC6fmkhIW9UDbxJJ+SNBCFvCoGQvwQS8kYgUDcZTsgybxujJtfDgdZjMxMhb2YkZLdGaEJG5vUbJkL+JgWEPBC3V2hj2xbVwN/qhLyFGNu+jfKPbd4kBh3btgCB+q2lY5uNoPxOgep7HZTfEaD83jJQfgcE5feWgnKLhdJ1qwLVNh2UWwnpui0E6YpgN1e6bgWCcpvh0lXmbWvU5Ho40Hr8wCRdf2CUrm6N0NIVmdcfmaTrjymQrt9bSMjbVQPv0Al5O0HIO0Ig5O+BhLwdCNQdhhOyzNv2qMn1cKD1+ImJkH9iJGS3RmhCRub1ZyZC/jkFhHwjbq/QxradqoF/0Ql5JzG2/RLlH9u8SQw6tu0EAvUXS8c2G0G5S4HqVx2UuwhQ/moZKHcBQfmrpaDcaaF03a1A9ZsOyt2EdP0tBOmKYDdXuu4GgvI3w6WrzNvuqMn1cKD1+J1Juv7OKF3dGqGlKzKvfzBJ1z9SIF1/tZCQ96gG/lMn5D0EIf8ZAiH/CiTkPUCg/mk4Icu87YmaXA8HWo+/mAj5L0ZCdmuEJmRkXv9mIuS/U0DIN+H2Cm1s26saeJ9OyHuJsW1flH9s8yYx6Ni2FwjUfZaObTaC0gVZug5AuaD70jPsAqUMNuheLijTM+wE5V4LpWtEJSiqA1Au6NJV/iVu6boXKF0jQFBGM7DFRUtXmTf5vObWw4HWIwNWj5zSNSODT7q6NUJLV2ReM4Hk681rZkb40jU9wz5CjqkExXVCjhGEHA+BkNMzcIQcAwI1bjghy7zFMkyuhwOtRwEmQi7ASMhujdCEjMxrQSZCLpgCQh6E2yu0sa2QSlBhnZALEWNb4RDGNm8Sg45thYBALWzp2GYjKIuoBBXVAViEAGVRy0BZBAjKopaCspCF0rWYSlBxHYDFCOlaPATpWggmlRLJYkBQFjdcusq8FcswuR4OtB5HMEnXIxilq1sjtHRF5vVIJul6ZAqka1ELCbmESlBJnZBLEIRcMgRCLgok5BJAoJY0nJBl3kpkmFwPB1qPUkyEXIqRkN0aoQkZmdfSTIRcOgWEfDNur9DGtjIqQWV1Qi5DjG1lQxjbvEkMOraVAQK1rKVjm42gPEolqJwOwKMIUJazDJRHAUFZzlJQlrFQupZXCaqgA7A8IV0rhCBdy8CkUiJZHgjKCoZLV5m38hkm18OB1uNoJul6NKN0dWuElq7IvB7DJF2PSYF0LWchIVdUCTpWJ+SKBCEfGwIhlwMSckUgUI81nJBl3ipmmFwPB1qP45gI+ThGQnZrhCZkZF6PZyLk41NAyINxe4U2tlVSCTpBJ+RKxNh2QghjmzeJQce2SkCgnmDp2GYjKCurBJ2oA7AyAcoTLQNlZSAoT7QUlJUslK5VVIKq6gCsQkjXqiFI10owqZRIVgGCsqrh0lXmrUqGyfVwoPU4iUm6nsQoXd0aoaUrMq8nM0nXk1MgXU+0kJCrqQRV1wm5GkHI1UMg5BOBhFwNCNTqhhOyzFu1DJPr4UDrUYOJkGswErJbIzQhI/N6ChMhn5ICQr4Ft1doY1tNlaBTdUKuSYxtp4YwtnmTGHRsqwkE6qmWjm02gtJNUFIHYIIAZdIyUCaAoExaCsqaFkrXLJWgWjoAswjpWisE6VoTJpUSySwgKGsZLl1l3rIyTK6HA61HbSbpWptRuro1QktXZF7rMEnXOimQrkkLCbmuSlC2Tsh1CULODoGQk0BCrgsEarbhhCzzVjfD5Ho40HrUYyLkeoyE7NYITcjIvNZnIuT6KSDkIbi9QhvbGqgEnaYTcgNibDsthLHNm8SgY1sDIFBPs3RssxGUDVWCTtcB2JAA5emWgbIhEJSnWwrKBhZK10YqQWfoAGxESNczQpCuDWBSKZFsBATlGYZLV5m3Rhkm18OB1uNMJul6JqN0dWuElq7IvDZmkq6NUyBdT7eQkJuoBJ2lE3ITgpDPCoGQTwcSchMgUM8ynJBl3ppkmFwPB1qPs5kI+WxGQnZrhCZkZF7PYSLkc1JAyLfi9gptbGuqEnSuTshNibHt3BDGNm8Sg45tTYFAPdfSsc1GUJ6nEnS+DsDzCFCebxkozwOC8nxLQdnUQunaTCXoAh2AzQjpekEI0rUpTColks2AoLzAcOkq89Ysw+R6ONB6XMgkXS9klK5ujdDSFZnXi5ik60UpkK7nW0jIzVWCLtYJuTlByBeHQMjnAwm5ORCoFxtOyDJvzTNMrocDrcclTIR8CSMhuzVCEzIyr5cyEfKlKSDk23B7hTa2tVAJukwn5BbE2HZZCGPbbWm4sa0FEKiXWTq23ZZmHygvVwm6Qgfg5QQor7AMlJcDQXmFpaBsYaF0bakSdKUOwJaEdL0yBOnaAiaVEsmWQFBeabh0lXlrmWFyPRxoPa5ikq5XMUpXt0Zo6YrM69VM0vXqFEjXKywk5FYqQa11Qm5FEHLrEAj5CiAhtwICtbXhhCzz1irD5Ho40Hq0YSLkNoyE7NYITcjIvF7DRMjXpICQb8ftFdrY1lYl6FqdkNsSY9u1IYxt3iQGHdvaAoF6raVjm42gvE4lqJ0OwOsIULazDJTXAUHZzlJQtrVQurZXCeqgA7A9IV07hCBd28KkUiLZHgjKDoZLV5m39hkm18OB1sNhkq4Oo3R1a4SWrsi8dmSSrh1TIF3bWUjInVSCOuuE3Ikg5M4hEHI7ICF3AgK1s+GELPPWKcPkejjQelzPRMjXMxKyWyM0ISPz2oWJkLukgJCH4vYKbWzrqhLUTSfkrsTY1i2Esc2bxKBjW1cgULtZOrbZCMruKkE9dAB2J0DZwzJQdgeCsoeloOxqoXTtqRLUSwdgT0K69gpBunaFSaVEsicQlL0Ml64ybz0zTK6HA63HDUzS9QZG6erWCC1dkXntzSRde6dAuvawkJD7qAT11Qm5D0HIfUMg5B5AQu4DBGpfwwlZ5q1Phsn1cKD16MdEyP0YCdmtEZqQkXntz0TI/VNAyHfg9gptbBugEjRQJ+QBxNg2MISxzZvEoGPbACBQB1o6ttkIyhtVgm7SAXgjAcqbLAPljUBQ3mQpKAdYKF0HqQTdrANwECFdbw5Bug6ASaVEchAQlDcbLl1l3gZlmFwPB1qPwUzSdTCjdHVrhJauyLzewiRdb0mBdL3JQkIeohJ0q07IQwhCvjUEQr4JSMhDgEC91XBClnkbkmFyPRxoPW5jIuTbGAnZrRGakJF5vZ2JkG9PASEPw+0V2tg2VCXoDp2QhxJj2x0hjG3eJAYd24YCgXqHpWObjaAcphJ0pw7AYQQo77QMlMOAoLzTUlAOtVC6DlcJGqEDcDghXUeEIF0R7OZK1+FAUI4wXLrKvA3PMLkeDrQedzFJ17sYpatbI7R0Reb1bibpencKpOudFhLySJWge3RCHkkQ8j0hEPKdQEIeCQTqPYYTsszbyAyT6+FA6zGKiZBHMRKyWyM0ISPzOpqJkEengpBxe4U2to1RCbpXJ+QxxNh2bwhjmzeJQce2MUCg3mvp2GYjKO9TCRqrA/A+ApRjLQPlfUBQjrUUlGMslK7jVILu1wE4jpCu94cgXcfApFIiOQ4IyvsNl64yb+MyTK6HA63HeCbpOp5Ruro1QktXZF4nMEnXCSmQrmMtJOSJKkEP6IQ8kSDkB0Ig5LFAQp4IBOoDhhOyzNvEDJPr4UDr8SATIT/ISMhujdCEjMzrQ0yE/FAKCHk4bq/QxrZJKkGTdUKeRIxtk0MY27xJDDq2TQICdbKlY5uNoHxYJWiKDsCHCVBOsQyUDwNBOcVSUE6yULpOVQl6RAfgVEK6PhKCdJ0Ek0qJ5FQgKB8xXLrKvE3NMLkeDrQejzJJ10cZpatbI7R0Reb1MSbp+lgKpOsUCwl5mkrQ4zohTyMI+fEQCHkKkJCnAYH6uOGELPM2LcPkejjQekxnIuTpjITs1ghNyMi8zmAi5BkpIOQRuL1CG9tmqgTN0gl5JjG2zQphbPMmMejYNhMI1FmWjm02gvIJlaAndQA+QYDySctA+QQQlE9aCsqZFkrX2SpBT+kAnE1I16dCkK4zYVIpkZwNBOVThktXmbfZGSbXw4HW42km6fo0o3R1a4SWrsi8PsMkXZ9JgXR90kJCnqMS9KxOyHMIQn42BEJ+EkjIc4BAfdZwQpZ5m5Nhcj0caD2eYyLk5xgJ2a0RmpCReX2eiZCfTwEh34XbK7Sxba5K0As6Ic8lxrYXQhjbvEkMOrbNBQL1BUvHNhtB+aJK0Es6AF8kQPmSZaB8EQjKlywF5VwLpes8laCXdQDOI6TryyFI17kwqZRIzgOC8mXDpavM27wMk+vhQOvxCpN0fYVRuro1QktXZF5fZZKur6ZAur5kISHPVwl6TSfk+QQhvxYCIb8EJOT5QKC+Zjghy7zNzzC5Hg60Hq8zEfLrjITs1ghNyMi8vsFEyG+kgJDvxu0V2ti2QCVooU7IC4ixbWEIY5s3iUHHtgVAoC60dGyzEZRvqgS9pQPwTQKUb1kGyjeBoHzLUlAusFC6LlIJelsH4CJCur4dgnRdAJNKieQiICjfNly6yrwtyjC5Hg60HouZpOtiRunq1ggtXZF5fYdJur6TAun6loWEvEQl6F2dkJcQhPxuCIT8FpCQlwCB+q7hhCzztiTD5Ho40Hq8x0TI7zESslsjNCEj8/o+EyG/nwJCHonbK7SxbalK0DKdkJcSY9uyEMY2bxKDjm1LgUBdZunYZiMol6sEfaADcDkByg8sA+VyICg/sBSUSy2UritUgj7UAbiCkK4fhiBdl8KkUiK5AgjKDw2XrjJvKzJMrocDrcdHTNL1I0bp6tYILV2Ref2YSbp+nALp+oGFhLxSJegTnZBXEoT8SQiE/AGQkFcCgfqJ4YQs87Yyw+R6ONB6rGIi5FWMhOzWCE3IyLx+ykTIn6aAkO/B7RXa2LZaJWiNTsiribFtTQhjmzeJQce21UCgrrF0bLMRlJ+pBH2uA/AzApSfWwbKz4Cg/NxSUK62ULquVQn6QgfgWkK6fhGCdF0Nk0qJ5FogKL8wXLrKvK3NMLkeDrQe65ik6zpG6erWCC1dkXn9kkm6fpkC6fq5hYS8XiXoK52Q1xOE/FUIhPw5kJDXA4H6leGELPO2PsPkejjQenzNRMhfMxKyWyM0ISPzuoGJkDekgJBH4fYKbWzbqBK0SSfkjcTYtimEsc2bxKBj20YgUDdZOrbZCMrNKkHf6ADcTIDyG8tAuRkIym8sBeVGC6XrFpWgb3UAbiGk67chSNeNMKmUSG4BgvJbw6WrzNuWDJPr4UDr8R2TdP2OUbq6NUJLV2Rev2eSrt+nQLp+YyEhb1UJ2qYT8laCkLeFQMjfAAl5KxCo2wwnZJm3rRkm18OB1uMHJkL+gZGQ3RqhCRmZ1x+ZCPnHFBDyaNxeoY1t21WCduiEvJ0Y23aEMLZ5kxh0bNsOBOoOS8c2G0H5k0rQzzoAfyJA+bNloPwJCMqfLQXldgul606VoF90AO4kpOsvIUjX7TCplEjuBILyF8Olq8zbzgyT6+FA67GLSbruYpSubo3Q0hWZ11+ZpOuvKZCuP1tIyLtVgn7TCXk3Qci/hUDIPwMJeTcQqL8ZTsgyb7szTK6HA63H70yE/DsjIbs1QhMyMq9/MBHyHykg5DG4vUIb2/aoBP2pE/IeYmz7M4SxzZvEoGPbHiBQ/7R0bLMRlH+pBP2tA/AvApR/WwbKv4Cg/NtSUO6xULruVQnapwNwLyFd94UgXffApFIiuRcIyn2GS1eZt70ZJtfDgdYjLZNHusp9uaSrWyO0dEXmNT0TR77evKZnhi9d/7aQkCOZ+/+MZqblJF+5oBNyNJOfkP8GEnIkEwfUaKbZhCzzJp/X3Ho40HpkMBFyBiMhuzVCEzIyr5lMhJyZAkK+F7dXaGNbTBFyXCdkuaCr5ngm/9jmTWLQsS0GBGocCNR8UP4rzBygLKBAWVAHZQEClAUtA2UBICgLWgrKGFjdpHGAUpOuhRQoC+ugLERI18IhSFcEu7nStRAQlIUNl64yb4UyTa6HA61HESbpWoRRuro1QktXZF6LMknXoimQrgUtJORiipCL64RcjCDk4iEQckEgIRcDArW44YQs81Ys0+R6ONB6HMFEyEcwErJbIzQhI/N6JBMhH5kCQr4Pt1doY1sJRcgldUIuQYxtJUMY27xJDDq2lQACtaSlY5uNoCylQFlaB2UpApSlLQNlKSAoS1sKyhIWStcyCpRldVCWIaRr2RCkawmgdC0DBGVZw6WrzFuZTJPr4UDrcRSTdD2KUbq6NUJLV2ReyzFJ13IpkK6lLSTk8oqQK+iEXJ4g5AohEHJpICGXBwK1guGELPNWPtPkejjQehzNRMhHMxKyWyM0ISPzegwTIR+TAkIei9srtLGtoiLkY3VCrkiMbceGMLZ5kxh0bKsIBOqxlo5tNoLyOAXK43VQHkeA8njLQHkcEJTHWwrKihZK10oKlCfooKxESNcTQpCuFYHStRIQlCcYLl1l3iplmlwPB1qPykzStTKjdHVrhJauyLyeyCRdT0yBdD3eQkKuogi5qk7IVQhCrhoCIR8PJOQqQKBWNZyQZd6qZJpcDwdaj5OYCPkkRkJ2a4QmZGReT2Yi5JNTQMjjcHuFNrZVU4RcXSfkasTYVj2Esc2bxKBjWzUgUKtbOrbZCMoaCpSn6KCsQYDyFMtAWQMIylMsBWU1C6VrTQXKU3VQ1iSk66khSNdqQOlaEwjKUw2XrjJvNTNNrocDrUeCSbomGKWrWyO0dEXmNckkXZMpkK6nWEjIWYqQa+mEnEUQcq0QCPkUICFnAYFay3BClnnLyjS5Hg60HrWZCLk2IyG7NUITMjKvdZgIuU4KCPl+3F6hjW11FSFn64RclxjbskMY27xJDDq21QUCNdvSsc1GUNZToKyvg7IeAcr6loGyHhCU9S0FZV0LpWsDBcrTdFA2IKTraSFI17pA6doACMrTDJeuMm8NMk2uhwOtR0Mm6dqQUbq6NUJLV2ReT2eSrqenQLrWt5CQGylCPkMn5EYEIZ8RAiHXBxJyIyBQzzCckGXeGmWaXA8HWo8zmQj5TEZCdmuEJmRkXhszEXLjFBDyeNxeoY1tTRQhn6UTchNibDsrhLHNm8SgY1sTIFDPsnRssxGUZytQnqOD8mwClOdYBsqzgaA8x1JQNrFQujZVoDxXB2VTQrqeG4J0bQKUrk2BoDzXcOkq89Y00+R6ONB6nMckXc9jlK5ujdDSFZnX85mk6/kpkK7nWEjIzRQhX6ATcjOCkC8IgZDPARJyMyBQLzCckGXemmWaXA8HWo8LmQj5QkZCdmuEJmRkXi9iIuSLUkDIE3B7hTa2NVeEfLFOyM2Jse3iEMY2bxKDjm3NgUC92NKxzUZQXqJAeakOyksIUF5qGSgvAYLyUktB2dxC6dpCgfIyHZQtCOl6WQjStTlQurYAgvIyw6WrzFuLTJPr4UDrcTmTdL2cUbq6NUJLV2Rer2CSrlekQLpeaiEht1SEfKVOyC0JQr4yBEK+FEjILYFAvdJwQpZ5a5lpcj0caD2uYiLkqxgJ2a0RmpCReb2aiZCvTgEhT8TtFdrY1koRcmudkFsRY1vrEMY2bxKDjm2tgEBtbenYZiMo2yhQXqODsg0BymssA2UbICivsRSUrSyUrm0VKK/VQdmWkK7XhiBdWwGla1sgKK81XLrKvLXNNLkeDrQe1zFJ1+sYpatbI7R0Rea1HZN0bZcC6XqNhYTcXhFyB52Q2xOE3CEEQr4GSMjtgUDtYDghy7y1zzS5Hg60Hg4TITuMhOzWCE3IyLx2ZCLkjikg5Adwe4U2tnVShNxZJ+ROxNjWOYSxzZvEoGNbJyBQO1s6ttkIyusVKLvooLyeAGUXy0B5PRCUXSwFZScLpWtXBcpuOii7EtK1WwjStRNQunYFgrKb4dJV5q1rpsn1cKD16M4kXbszSle3RmjpisxrDybp2iMF0rWLhYTcUxFyL52QexKE3CsEQu4CJOSeQKD2MpyQZd56ZppcDwdajxuYCPkGRkJ2a4QmZGReezMRcu8UEPKDuL1CG9v6KELuqxNyH2Js6xvC2OZNYtCxrQ8QqH0tHdtsBGU/Bcr+Oij7EaDsbxko+wFB2d9SUPaxULoOUKAcqINyACFdB4YgXfsApesAICgHGi5dZd4GZJpcDwdajxuZpOuNjNLVrRFauiLzehOTdL0pBdK1v4WEPEgR8s06IQ8iCPnmEAi5P5CQBwGBerPhhCzzNijT5Ho40HoMZiLkwYyE7NYITcjIvN7CRMi3pICQH8LtFdrYNkQR8q06IQ8hxrZbQxjbvEkMOrYNAQL1VkvHNhtBeZsC5e06KG8jQHm7ZaC8DQjK2y0F5RALpetQBco7dFAOJaTrHSFI1yFA6ToUCMo7DJeuMm9DM02uhwOtxzAm6TqMUbq6NUJLV2Re72SSrnemQLrebiEhD1eEPEIn5OEEIY8IgZBvBxLycCBQRxhOyDJvwzNNrocDrcddTIR8FyMhuzVCEzIyr3czEfLdKSDkSbi9QhvbRipCvkcn5JHE2HZPCGObN4lBx7aRQKDeY+nYZiMoRylQjtZBOYoA5WjLQDkKCMrRloJypIXSdYwC5b06KMcQ0vXeEKTrSKB0HQME5b2GS1eZtzGZJtfDgdbjPibpeh+jdHVrhJauyLyOZZKuY1MgXUdbSMjjFCHfrxPyOIKQ7w+BkEcDCXkcEKj3G07IMm/jMk2uhwOtx3gmQh7PSMhujdCEjMzrBCZCnpACQp6M2yu0sW2iIuQHdEKeSIxtD4QwtnmTGHRsmwgE6gOWjm02gvJBBcqHdFA+SIDyIctA+SAQlA9ZCsqJFkrXSQqUk3VQTiKk6+QQpOtEoHSdBATlZMOlq8zbpEyT6+FA6/Ewk3R9mFG6ujVCS1dkXqcwSdcpKZCuD1lIyFMVIT+iE/JUgpAfCYGQHwIS8lQgUB8xnJBl3qZmmlwPB1qPR5kI+VFGQnZrhCZkZF4fYyLkx1JAyA/j9gptbJumCPlxnZCnEWPb4yGMbd4kBh3bpgGB+rilY5uNoJyuQDlDB+V0ApQzLAPldCAoZ1gKymkWSteZCpSzdFDOJKTrrBCk6zSgdJ0JBOUsw6WrzNvMTJPr4UDr8QSTdH2CUbq6NUJLV2Ren2SSrk+mQLrOsJCQZytCfkon5NkEIT8VAiHPABLybCBQnzKckGXeZmeaXA8HWo+nmQj5aUZCdmuEJmRkXp9hIuRnUkDIU3B7hTa2zVGE/KxOyHOIse3ZEMY2bxKDjm1zgEB91tKxzUZQPqdA+bwOyucIUD5vGSifA4LyeUtBOcdC6TpXgfIFHZRzCen6QgjSdQ5Qus4FgvIFw6WrzNvcTJPr4UDr8SKTdH2RUbq6NUJLV2ReX2KSri+lQLo+byEhz1OE/LJOyPMIQn45BEJ+HkjI84BAfdlwQpZ5m5dpcj0caD1eYSLkVxgJ2a0RmpCReX2ViZBfTQEhT8XtFdrYNl8R8ms6Ic8nxrbXQhjbvEkMOrbNBwL1NUvHNhtB+boC5Rs6KF8nQPmGZaB8HQjKNywF5XwLpesCBcqFOigXENJ1YQjSdT5Qui4AgnKh4dJV5m1Bpsn1cKD1eJNJur7JKF3dGqGlKzKvbzFJ17dSIF3fsJCQFylCflsn5EUEIb8dAiG/ASTkRUCgvm04Icu8Lco0uR4OtB6LmQh5MSMhuzVCEzIyr+8wEfI7KSDkR3B7hTa2LVGE/K5OyEuIse3dEMY2bxKDjm1LgEB919KxzUZQvqdA+b4OyvcIUL5vGSjfA4LyfUtBucRC6bpUgXKZDsqlhHRdFoJ0XQKUrkuBoFxmuHSVeVuaaXI9HGg9ljNJ1+WM0tWtEVq6IvP6AZN0/SAF0vV9Cwl5hSLkD3VCXkEQ8ochEPL7QEJeAQTqh4YTsszbikyT6+FA6/EREyF/xEjIbo3QhIzM68dMhPxxCgj5UdxeoY1tKxUhf6IT8kpibPskhLHt0TTc2LYSCNRPLB3bHk2zD5SrFCg/1UG5igDlp5aBchUQlJ9aCsqVFkrX1QqUa3RQriak65oQpOtKoHRdDQTlGsOlq8zb6kyT6+FA6/EZk3T9jFG6ujVCS1dkXj9nkq6fp0C6fmohIa9VhPyFTshrCUL+IgRC/hRIyGuBQP3CcEKWeVubaXI9HGg91jER8jpGQnZrhCZkZF6/ZCLkL1NAyI/h9gptbFuvCPkrnZDXE2PbVyGMbd4kBh3b1gOB+pWlY5uNoPxagXKDDsqvCVBusAyUXwNBucFSUK63ULpuVKDcpINyIyFdN4UgXdcDpetGICg3GS5dZd42ZppcDwdaj81M0nUzo3R1a4SWrsi8fsMkXb9JgXTdYCEhb1GE/K1OyFsIQv42BELeACTkLUCgfms4Icu8bck0uR4OtB7fMRHyd4yE7NYITcjIvH7PRMjf+xDyEeA8rxebb4zgCHOD2GtLBJdjGdv6CJDnxF4bMM+blP+zVey1HbFfcv8fP4q9doKeV+4qY9sK2W9/lDK2H4M/b9K92S322hN0v+SB2z/EXnuDP2+Wwl9SxrY76H61/8FzUsb2R7DnTXpfRARpxKIB9kvmfJkp9ioUDfS8CU//JmVskSD7ZeXgg6SMTcbIwYNIDsTElZWN4uas7ERiC5j3kJwXPC75hIkEgov375RI7ATzHJLjgsXlPmEiEZR7D+yUSOwF8xqS0w49Lu8TJhJBuDbnTolEoQB71dL+L424DnHvpO7w6s+tagjepg/BcmGB5tvmEcjuVSJYcP8KNp+483zlE3fer3zizvt1WBP3QQrahDbgJrcCDyS2ZeLeUNyPPd2DHe+FPpDb6hP3we7tjfeHTMaAf8jD6dTB/pwfcCdKyR+BwOLK4Y+ZuZ8cHuzP+RF4Ksfx3NvUc+eGndwufV9kvbcznWzKfRunhXOyWUz80BJR0H7ijelIsVeZKC7HMrZigP3ck00Z25GY5/3f23B5sVdFxH7qTf0YsVcl0PPKXWVs5SH77Y9SxnZM8Of9R8JUEXtVC7qfRxCdLPaqGfx5/znZlLFVCbqf52RTxnZysOfNIf+yxF51gWKyjtirAfBkU8aWBTzZlLHVifLwIJIDMXFlZaO4WYrzMmDeQ3Je8Lj2jx8ILnYHmUpgnkNyXLC4DoxqQbnXO/TVBPMaktMOPa6cY20QrtUH5AYWnmzuUMPiT/rJ5g7iZPOnEE4284k7z1c+cef9yifuvF+HNXEHPdncATyQ+MnSk80dTCebP2cyBvwzw8nmz8CTzZ2Gn2zKHO5kONncafjJ5k/quXPDTm6Xvi+y3r8wnWz+EuLJZiPxQ5sAxWFjsVdT4MmmjK0R8GRTxtYYKBSbib2aA8XiRWKvFsCTTRlbM+DJpoztIqBwbCn2agUUj1eLvdoCTzZlbC2BJ5sytquBQrK92KsTUEx2FHt1BZ5sytjaA082ZWwdozw8iORATFxZ2ShuluK8KZj3kJwXPK794weCi91BpgWY55AcFyyuA6NaUO71Dn1twbyG5LRDjyvnWBuEa/UBuauFJ5u71LD4q36yuYs42fw1hJPNfOLO85VP3Hm/8ok779dhTdxBTzZ3AQ8kfrX0ZHMX08nm7kzGgHcznGzuBp5s/mb4yabM4W8MJ5u/GX6y+at67tywk9ul74us9+9MJ5u/h3iy2VP80D5Acdhb7DUAeLIpY+sJPNmUsfUGCsVBYq8hQLF4i9hrKPBkU8Y2CHiyKWO7BSgch4u9RgLF491irzHAk00Z23DgyaaM7W6gkBwn9poIFJMTxF6TgCebMrZxwJNNGduEKA8PIjkQE1dWNoqbpTgfAOY9JOcFj2v/+IHgYneQGQrmOSTHBYvrwKgWlHu9Q98YMK8hOe3Q48o51gbhWn1AnmThyeYfaljco59s/kGcbO4J4WQzn7jzfOUTd96vfOLO+3VYE3fQk80/gAcSeyw92fyD6WTzz0zGgP9kONn8E3iy+ZfhJ5syh38xnGz+ZfjJ5h713LlhJ7dL3xdZ77+ZTjb/DvFkc6r4odOA4vAxsddM4MmmjG0q8GRTxvYYUCjOFnvNAYrFZ8Rec4EnmzK22cCTTRnbM0DhOE/sNR8oHl8Vey0AnmzK2OYBTzZlbK8CheQisdcSoJh8R+y1FHiyKWNbBDzZlLG9E+XhQSQHYuLKykZxsxTnM8G8h+S84HHtHz8QXOwOMnPBPIfkuGBxHRjVgnKvd+hbAOY1JKcdelw5x9ogXKsPyEstPNncq4bFffrJ5l7iZHNfCCeb+cSd5yufuPN+5RN33q/DmriDnmzuBR5I7LP0ZHMv08lmWowxYLk5+mRT7nmoBdSuZHrM7JNNmUMZI/pkMx2XQ5bn3qeeOzfs5Hbp+yLrHQHm0CsI5b5hnWyuED90JVAcfiz2Wg082ZSxrQCebMrYPgYKxbVir/VAsfil2Gsj8GRTxrYWeLIpY/sSKBy3iL22AsXj92Kv7cCTTRnbFuDJpozte6CQ3Cn22g0Uk7+KvfYATzZlbDuBJ5sytl+jPDyI5EBMXFnZKG6W4nw1mPeQnBc8rv3jB4KL3UFmI5jnkBwXLK4Do1pQ7vUOfdvBvIbktEOPK+dYG4Rr9QF5j4Unm1E1LGbIP72iVS7oJ5sZMf6TzXzizvOVT9x5v/KJO+/XYU3cQU82o8ADiYwY7g0lzJPNaIznZDMzxhhwJsPJZibwZDNm+MmmzGGM4WQzZvjJZoZ67tywk9ul74usd5zpZDMe4snmXvFDIxk4cZgu9oplAE+PxV57gSebMrZ0zPP+7224kNirGGI/9aZeVOxVIgPzvHJXGVshyH77o5SxFQ3+vP9ImDJir/JB9/MIonJir4rBn/efk00ZW5mg+3lONmVs5YI9bw75V0nsVSXIfpqYPFHsVS3Y8+Y42ZSxVQqyn3ayKWOTMXLwIJIDMXFlZaO4WYrzGJj3kJwXPK794weCi91BpgSY55AcFyyuA6NaUO71Dn0VwbyG5LRDjyvnWBuEa/UBuVqAvVJ1sllADYsF9ZPNAsTJZsEQTjbziTvPVz5x5/3KJ+68X4c1cQc92SwAPJAoaOnJZgGmk81CMcaACzGcbBYCnmwWNvxkU+awMMPJZmHDTzYLqufODTu5Xfq+yHoXYTrZLBLiyWZN8UOygCebSbFXXeDJpoytJuikT55sytiSQKHYQOzVCCgWTxd7NQGebMrYGgBPNmVspwOFY1OxVzOgeDxf7NUceLIpY2sKPNmUsZ0PFJItxF4tgWLyCrFXK+DJpoytBfBkU8Z2RQYPDyI5EBNXVjaKm6U4rwvmPSTnBY9r//iB4GJ3kGkC5jkkxwWL68CoFpR7vUNfczCvITnt0OPKOdYG4Vp9QG5l4clmUTUsFtNPNosSJ5vFQjjZzCfuPF/5xJ33K5+4834d1sQd9GSzKPBAopilJ5tFmU42i8cYAy7OcLJZHHiyeYThJ5syh0cwnGweYfjJZjH13LlhJ7dL3xdZ7yOZTjaPDPFks634Ie2B4rCd2KsT8GRTxtYWeLIpY2sHFIpdxV49gWKxh9irD/BkU8bWFXiyKWPrARSOA8Reg4Di8Sax1xDgyaaMbQDwZFPGdhNQSA4Vew0Hisk7xV4jgSebMrahwJNNGdudGTw8iORATFxZ2ShuluK8E5j3kJwXPK794weCi91Bpg+Y55AcFyyuA6NaUO71Dn1DwLyG5LRDjyvnWBuEa/UBeaSFJ5sl1LBYUj/ZLEGcbJYM4WQzn7jzfOUTd96vfOLO+3VYE3fQk80SwAOJkpaebJZgOtksFWMMuBTDyWYp4MlmacNPNmUOSzOcbJY2/GSzpHru3LCT26Xvi6x3GaaTzTIhnmyOET9kHFAcjhV7TQSebMrYxgBPNmVsY4FCcZLYaypQLE4Re00DnmzK2CYBTzZlbFOAwnGm2Gs2UDw+KfaaAzzZlLHNBJ5sytieBArJuWKveUAx+ZLYaz7wZFPGNhd4siljeymDhweRHIiJKysbxc1SnE8E8x6S84LHtX/8QHCxO8hMA/MckuOCxXVgVAvKvd6hbw6Y15Ccduhx5Rxrg3CtPiDPt/Bks6waFo/STzbLEiebR4VwsplP3Hm+8ok771c+cef9OqyJO+jJZlnggcRRlp5slmU62SwXYwy4HMPJZjngyWZ5w082ZQ7LM5xsljf8ZPMo9dy5YSe3S98XWe8KTCebFUI82VwgfsgioDh8S+y1BHiyKWNbADzZlLG9BRSKS8VeK4Bi8QOx10rgyaaMbSnwZFPG9gFQOK4We60FisfPxV7rgSebMrbVwJNNGdvnQCG5Uey1BSgmvxF7bQWebMrYNgJPNmVs32Tw8CCSAzFxZWWjuFmK8yVg3kNyXvC49o8fCC52B5mVYJ5DclywuA6MakG51zv0rQfzGpLTDj2unGNtEK7VB+StFp5sHq2GxWP0k82jiZPNY0I42cwn7jxf+cSd9yufuPN+HdbEHfRk82jggcQxlp5sHs10slkxxhhwRYaTzYrAk81jDT/ZlDk8luFk81jDTzaPUc+dG3Zyu/R9kfU+julk87gQTza3ix+yEygOfxZ77QaebMrYtgNPNmVsPwOF4h6x116gWPxb7BXJxJ1sytj2AE82ZWx/A4VjTOxXKBMnHguKvYoFz98/J5sytljQ/TwnmzK2gsGeN4f8KyH2KhNkP01MlhZ7lQ/2vDlONmVsJYLsp51sythkjBw8iORATFxZ2TuBA/JuMO8hOS94XPvHj73AATmSieU5JMcFi+vAqBaUe71DXzEwryE57dDjyjnWBuFafUAuH2CvVJ1sHq+GxUr6yebxxMlmpRBONvOJO89XPnHn/con7rxfhzVxBz3ZPB54IFHJ0pPN45lONk+IMQZ8AsPJ5gnAk83Khp9syhxWZjjZrGz4yWYl9dy5YSe3S98XWe8TmU42TwzxZLOiIOlKmaD9xBvT8WKvKplAHIi9KoJO+uTJpozteMzz/u9tuJrYqyZiP/WmforYKwt4siljqwbZb3+UMrZTgMKxrtirAVA81hd7NQKebMrY6gJPNmVs9YFCsonYqylQTJ4j9moGPNmUsTUBnmzK2M7J5OFBJAdi4srKRnGzFOdVwLyH5Lzgce0fPxBc7A4yWWCeQ3JcsLgOjGpBudc79DUC8xqS0w49rpxjbRCu1QfkZhaebFZRw2JV/WSzCnGyWTWEk8184s7zlU/ceb/yiTvv12FN3EFPNqsADySqWnqyWYXpZPOkGGPAJzGcbJ4EPNk82fCTTZnDkxlONk82/GSzqnru3LCT26Xvi6x3NaaTzWohnmw2FyTdAigOLxV7tQSebMrYmgNPNmVslwKFYiuxV1ugWLxG7NUeeLIpY2sFPNmUsV0DFI6dxF5dgeKxi9irJ/BkU8bWCXiyKWPrAhSSfcReA4Bisr/YaxDwZFPG1gd4silj65/Jw4NIDsTElZWN4mYpzluCeQ/JecHj2j9+ILjYHWTag3kOyXHB4jowqgXlXu/Q1xPMa0hOO/S4co61QbhWH5AHWXiyWV0NizX0k83qxMlmjRBONvOJO89XPnHn/con7rxfhzVxBz3ZrA48kKhh6clmdaaTzVNijAGfwnCyeQrwZLOm4SebMoc1GU42axp+sllDPXdu2Mnt0vdF1vtUppPNU0M82RwiSHooUBzeLvYaDjzZlLENAZ5sythuBwrFkWKvMUCxOFrsNQ54siljGwk82ZSxjQYKx4lir0lA8fiQ2Gsq8GRTxjYReLIpY3sIKCSnib1mAsXkDLHXbODJpoxtGvBkU8Y2I5OHB5EciIkrKxvFzVKcDwfzHpLzgse1f/xAcLE7yIwD8xyS44LFdWBUC8q93qFvKpjXkJx26HHlHGuDcK0+IM+28GQzoYbFpH6ymSBONpMhnGzmE3eer3zizvuVT9x5vw5r4g56spkAHkgkLT3ZTDCdbGbFGAPOYjjZzAKebNYy/GRT5rAWw8lmLcNPNpPquXPDTm6Xvi+y3rWZTjZrh3iyOUeQ9FygOHxe7DUPeLIpY5sDPNmUsT0PFIrzxV4LgGLxDbHXIuDJpoxtPvBkU8b2BlA4LhF7LQWKx/fFXiuAJ5sytiXAk00Z2/tAIblS7LUaKCY/FXutBZ5sythWAk82ZWyfZvLwIJIDMXFlZaO4WYrzeWDeQ3Je8Lj2jx8ILnYHmUVgnkNyXLC4DoxqQbnXO/StAPMaktMOPa6cY20QrtUH5LUWnmzWUcNiXf1ksw5xslk3hJPNfOLO85VP3Hm/8ok779dhTdxBTzbrAA8k6lp6slmH6WQzO8YYcDbDyWY28GSznuEnmzKH9RhONusZfrJZVz13btjJ7dL3Rda7PtPJZn2fk82MgPnQruR6QdIbgeJwg9hrC/BkU8a2HniyKWOTMXLkEZlDTFxZ2RuBAntLgL3qHbhNhjmJNVBvbqfpk1gDYhI7jZjEYsGC+1ewhxtQgiq/BkDCPi2GA3CYyq8Bk/JrGGMMuCGD8msIVH6nG678ZA5PZ1B+pxuu/E5Tz41Wfsh6N2JSfo2U8pP3hdSf2xSZyvufPPe/eu73eO73ee4zYgfuC3rui3nuS3ruj/LcH+O5r+S5r+q5r+G5T3ru63ruvaSLyln+fvn7Hex+Z0gcyv4S1kTYWcLOFnaOsKbCzhV2nrDzhTUTdoGwC4VdJKy5sIuFXSLsUmEthF0m7HJhVwhrKezK2P6pQvJWNO3fV248fpBX8gwwj+sXaO96bHsn93Onm9sC6v4qkZerhbUS1lpYG2HXCGsr7Fp9CpB/uYDmu5rwtSJ8rQlfG8J3DeFrS/iujR14CPcqiEyYBpqgb4JXAfZyx/KrQXvJZ2wF2Wt/vloH3+ufX5JpE3Qvzy/IXBNsrxy/fNI2yF7aL55cCySlMMn0zHwyJcn0OpGXdsLaC+sgzBHWUVgnYZ11Mr2OILV2hK894etA+BzC15HwdSJ8nUMg0zOBZHodkEzbAcm0PZBMOwDJ1AGSaUcgmXYCkmlnS8m0cT6ZkmR6vchLF2FdhXUT1l1YD2E9hfXSyfR6gtS6EL6uhK8b4etO+HoQvp6Er1cIZNoYSKbXA8m0C5BMuwLJtBuQTLsDybQHkEx7Asm0l6Vk2iSfTEkyvUHkpbewPsL6CusnrL+wAcIG6mR6A0FqvQlfH8LXl/D1I3z9Cd8AwjcwBDJtAiTTG4Bk2htIpn2AZNoXSKb9gGTaH0imA4BkOhBMpvKKpP37Qn+2NDQ9cNz//LYBES5sb28ubozt//MmndTkQrrmk3/pOC2oKGMSgzbLjUCiuinGU1x0/k5IhzUP5NzUjWsQuKldbOoXWiEh4/bGe3OMMeCbY/h9BwPBwPXcg2MHEgzal7VZKwObtRWwPrdY2qy3MDXrkBhjwEMYmvVWw5tVPvetljXricBmbQ2sz22WNuttTM16e4wx4NsZmnWo4c0qn3uoZc1aBdisbYD1ucPSZr2DqVmHxRgDHsbQrHca3qzyue+0rFmrApv1GmB9hlvarMOZmnVEjDHgEQzNepfhzSqf+y7LmvUkYLO2Bdbnbkub9W6mZh0ZYwx4JEOz3mN4s8rnvseyZj0Z2KzXAuszytJmHcXUrKNjjAGPZmjWMYY3q3zuMZY1azVgs14HrM+9ljbrvUzNel+MMeD7GJp1rOHNKp97rGXNWh3YrO2A9RlnabOOY2rW+2OMAd/P0KzjDW9W+dzjLWvWGsBmbQ+szwRLm3UCU7NOjDEGPJGhWR8wvFnlcz9gWbOeAmzWDsD6PGhpsz7I1KwPxRgDfoihWScZ3qzyuSdZ1qw1gc3qAOsz2dJmnczUrA/HGAN+mKFZpxjerPK5p1jWrKcCm7UjsD5TLW3WqUzN+kiMMeBHGJr1UcObVT73o5Y1awLYrJ2A9XnM0mZ9jKlZp8UYA57G0KyPG96s8rkft6xZk8Bm7Qysz3RLm3U6U7POiDEGPIOhWWca3qzyuWda1qxZwGa9HlifWZY26yymZn0ixhjwEwzN+qThzSqf+0nLmrUWsFm7AOsz29Jmnc3UrE/FGAN+iqFZnza8WeVzP21Zs9YGNmtXYH2esbRZn2Fq1jkxxoDnMDTrs4Y3q3zuZy1r1jrAZu0GrM9zljbrc0zN+nyMMeDnGZp1ruHNKp97rmXNWhfYrN2B9XnB0mZ9galZX4wxBvwiQ7O+ZHizyud+ybJmzQY2aw9gfeZZ2qzzmJr15RhjwC8zNOsrhjerfO5XLGvWesBm7Qmsz6uWNuurTM06P8YY8HyGZn3N8GaVz/2aZc1aH9isvYD1ed3SZn2dqVnfiDEG/AZDsy4wvFnlcy+wrFkbAJv1BmB9FlrarAuZmvXNGGPAbzI061uGN6t87rcsa9bTgM3aG1ifRZY26yKmZn07xhjw2wzNutjwZpXPvdiyZm0IbNY+wPq8Y2mzvsPUrEtijAEvYWjWdw1vVvnc71rWrKcDm7UvsD7vWdqs7zE16/sxxoDfZ2jWpYY3q3zupZY1ayNgs/YD1meZpc26jKlZl8cYA17O0KwfGN6s8rk/sKxZzwA2a39gfVZY2qwrmJr1wxhjwB8yNOtHhjerfO6PLGvWM4HNOgBYn48tbdaPmZp1ZYwx4JUMzfqJ4c0qn/sTy5q1MbBZBwLrs8rSZl3F1KyfxhgD/pShWVcb3qzyuVczNKul30OaJMJF7Z3je0jXqJx/FlMJcb9zdE3sQJe6PvmXjtOCMvl7SNcAQf9ZjKe46PydBXwHQX4P6eeWvoN8zvQOsjbGGPBahneQLwx/B5HP/YVlcu9sYLMiv4d0naXNuo6pWb+MMQb8JUOzrje8WeVzr7esWc8BNivye0i/srRZv2Jq1q9jjAF/zdCsGwxvVvncGyxr1qbAZkV+D+lGS5t1I1OzbooxBryJoVk3G96s8rk3W9as5wKbFfk9pN9Y2qzfMDXrlhhjwFsYmvVbw5tVPve3ljXrecBmRX4P6XeWNut3TM36fYwx4O8ZmnWr4c0qn3urZc16PrBZkd9Dus3SZt3G1Kw/xBgD/oGhWX80vFnlc/9oWbM2AzYr8ntIt1varNuZmnVHjDHgHQzN+pPhzSqf+yfLmvUCYLMiv4f0Z0ub9WemZt0ZYwx4J0Oz/mJ4s8rn/sWyZr0Q2KzI7yHdZWmz7mJq1l9jjAH/ytCsuw1vVvncuy1r1ouAzYr8HtLfLG3W35ia9fcYY8C/MzTrH4Y3q3zuPyxr1ubAZkV+D+keS5t1D1Oz/hljDPhPhmb9y/Bmlc/9l2XNejGwWZHfQ/q3pc36N1Oz7o0xBryXoVn3Gd6s8rn3WdaslwCbFfk9pGlxO5sVGbc33vQ4Y8Byc/S+kbjZzSqfOxI/kGDQvqzNeimwWZHfQxq1tFmjTM2aEWcMOIOhWTMNb1b53JmWNWsLYLMiv4c0ZmmzxpiaNR5nDDjO0KwFDG9W+dwFLGvWy4DNivwe0oKWNmtBpmYtFGcMuBBDsxY2vFnlcxe2rFkvBzYr8ntIi1jarEWYmrVonDHgogzNWszwZpXPXcyyZr0C2KzI7yEtbmmzFmdq1iPijAEfwdCsRxrerPK5j7SsWVsCmxX5PaQlLG3WEkzNWjLOGHBJhmYtZXizyucuZVmzXglsVuT3kJa2tFlLMzVrmThjwGUYmrWs4c0qn7usZc16FbBZkd9DepSlzXoUU7OWizMGXI6hWcsb3qzyuctb1qxXA5sV+T2kFSxt1gpMzXp0nDHgoxma9RjDm1U+9zGWNWsrYLMiv4e0oqXNWpGpWY+NMwZ8LEOzHmd4s8rnPs6yZm0NbFbk95Aeb2mzHs/UrJXijAFXYmjWEwxvVvncJ1jWrG2AzYr8HtLKljZrZaZmPTHOGPCJDM1axfBmlc9dxbJmvQbYrMjvIa1qabNWZWrWk+KMAZ/E0KwnG96s8rlPtqxZ2wKbFfk9pNUsbdZqTM1aPc4YcHWGZq1heLPK565hWbNeC2xW5PeQnmJps57C1Kw144wB12Ro1lMNb1b53Kda1qzXAZsV+T2kCUubNcHUrMk4Y8BJhmbNMrxZ5XNnWdas7YDNivwe0lqWNmstpmatHWcMuDZDs9YxvFnlc9dhaFZLv4c0iwgXtXeO7yGtq3KeHVcJcb9ztG78QJe6PvmXjtOCMvl7SOsCQZ8d5ykuOn8dgO8gyO8hrWfpO0g9pneQ+nHGgOszvIM0MPwdRD53A8vkngNsVuT3kJ5mabOextSsDeOMATdkaNbTDW9W+dynW9asHYHNivwe0kaWNmsjpmY9I84Y8BkMzXqm4c36v0JZ1qydgM2K/B7SxpY2a2OmZm0SZwy4CUOznmV4s8rnPsuyZu0MbFbk95CebWmzns3UrOfEGQM+h6FZmxrerPK5m1rWrNcDmxX5PaTnWtqs5zI163lxxoDPY2jW8w1vVvnc51vWrF2AzYr8HtJmljZrM6ZmvSDOGPAFDM16oeHNKp/7QsuatSuwWZHfQ3qRpc16EVOzNo8zBtycoVkvNrxZ5XNfbFmzdgM2K/J7SC+xtFkvYWrWS+OMAV/K0KwtDG9W+dwtLGvW7sBmRX4P6WWWNutlTM16eZwx4MsZmvUKw5tVPvcVljVrD2CzIr+HtKWlzdqSqVmvjDMGfCVDs15leLPK577KsmbtCWxW5PeQXm1ps17N1Kyt4owBt2Jo1taGN6t87taWNWsvYLMiv4e0jaXN2oapWa+JMwZ8DUOztjW8WeVzt7WsWW8ANivye0ivtbRZr2Vq1uvijAFfx9Cs7QxvVvnc7Sxr1t7AZkV+D2l7S5u1PVOzdogzBtyBoVkdw5tVPrdjWbP2ATYr8ntIO1rarB2ZmrVTnDHgTgzN2tnwZpXP3dmyZu0LbFbk95Beb2mzXs/UrF3ijAF3YWjWroY3q3zurpY1az9gsyK/h7Sbpc3ajalZu8cZA+7O0Kw9DG9W+dw9LGvW/sBmRX4PaU9Lm7UnU7P2ijMG3IuhWW8wvFnlc99gWbMOADYr8ntIe1varL2ZmrVPnDHgPgzN2tfwZpXP3deyZh0IbFbk95D2s7RZ+zE1a/84Y8D9GZp1gOHNKp97gGXNeiOwWZHfQzrQ0mYdyNSsN8YZA76RoVlvMrxZ5XPfZFmz3gRsVuT3kA6ytFkHMTXrzXHGgG9maNbBhjerfO7BljXrIGCzIr+H9BZLm/UWpmYdEmcMeAhDs95qeLPK577Vsma9GdisyO8hvc3SZr2NqVlvjzMGfDtDsw41vFnlcw+1rFkHA5sV+T2kd1jarHcwNeuwOGPAwxia9U7Dm1U+952WNestwGZFfg/pcEubdThTs46IMwY8gqFZ7zK8WeVz32VZsw4BNivye0jvtrRZ72Zq1pFxxoBHMjTrPYY3q3zueyxr1luBzYr8HtJRljbrKKZmHR1nDHg0Q7OOMbxZ5XOPsaxZbwM2K/J7SO+1tFnvZWrW++KMAd/H0KxjDW9W+dxjLWvW24HNivwe0nGWNus4pma9P84Y8P0MzTre8GaVzz2eoVkP5ntIE8GuZKV0HpLB5iSZ43tIJ6icT4yrhLjfOSoXMjTfROXzXlHGJB4qUDt2+t+VnAAE/cR4PijTQgLlAwqUD+qgfIAA5YOWgfIBICgftBSUE2Bxd6qbxgXKZM5vbH5IgXKSDsqH4gf0jOuTf6lAGi8oEey2H5SJ5ENAUE4CF1cHX9D4ZN7k85pbDwdaj8mwetRKeDE+2YNxDoKQOYhA962Tjczrw+DZws3rwyqvYRLygxYS8hRFyFN1Qp5CEPLUEAj5QSAhTwECdarhhCzzNiVucj0caD0eYSLkRxgJ2a0RmpCReX2UiZAfTQEhN7FwbHtMEfI0nZAfI8a2aSGMbU2AY9tjQKBOs3RssxGUjytQTtdB+TgByumWgfJxICinWwrKxyyUrjMUKGfqoJxBSNeZIUjXx4DSdQYQlDMNl64ybzPiJtfDgdZjFpN0ncUoXd0aoaUrMq9PMEnXJ1IgXadbSMhPKkKerRPykwQhzw6BkKcDCflJIFBnG07IMm9Pxk2uhwOtx1NMhPwUIyG7NUITMjKvTzMR8tMpIOT26faNbc8oQp6jE/IzxNg2J4SxzZvEoGPbM0CgzrF0bLMRlM8qUD6ng/JZApTPWQbKZ4GgfM5SUD5joXR9XoFyrg7K5wnpOjcE6foMULo+DwTlXMOlq8zb83GT6+FA6/ECk3R9gVG6ujVCS1dkXl9kkq4vpkC6PmchIb+kCHmeTsgvEYQ8LwRCfg5IyC8BgTrPcEKWeXspbnI9HGg9XmYi5JcZCdmtEZqQkXl9hYmQX/Eh5Axwnt1fyIPslzzwOz+oHMvYkL8QK2Pz/mY5Mo/IHGLiyspG1TYrO5GYAtqrlvi/NOI6xL2TusPbL6+qN+35+pu2XFig+eZ7HtC9YsGC+1ewhxtQDrJhExoBJF8Fksl8IIAP5r92DBr3qz5xH+ze3nhfizMG/Foe3r0P9ue8hnvHTb4OBBZXDl+P566sDvbnvA5ULRzPPV89d1Dlp++LrPcbTMpP7ts4LRzl5/76BGS/5IFPaFE5lrEhf31JxjY9zpNHZA4xcWVlzwC+oT9pofJboN7cFurKbwGh/BaGoPwON6AEVX4LgGSy0FLlt4BJ+b0ZZwz4TQbl9yZQ+b1luPKTOXyLQfm9ZbjyW6ieG638kPVexKT8FoWo/NwPuyD7JQ+cp6NyLGNDftgsY3suzpNHZA4xcWVlPw98Q3/JQuX3tnpzW6wrv7cJ5bc4BOV3uAElqPJ7G0gmiy1Vfm8zKb934owBv8Og/N4BKr8lhis/mcMlDMpvieHKb7F6brTyQ9b7XSbl965SfvK+UNq/P4hC/cz8/f7/76cfZeXnMn+/vO6ni+H8XObvl6r93hM4fF/YUmHLhC0X9oGwFcI+FPaRsI+FrRT2ibBVwj4VtlrYGmGfCftc2FphXwhbJ+xLYeuFfSXsa6WxIgr3H+Jxn5T7bNB+zmeAn1Mv8e98bYzn1A/vqZ8j79/33C/13C/z3C/33H/guV/hud/guf/Ic/+x536l5/4Tz/0qz/2nnvvVnvs1nvuNnvvPPfdrPfdfeO7Xee6/9Nyv99x/5bn/Wt1vEn9uFvaNsC3CvhX2nbDvhW0Vtk3YD8J+FLZd2A5hPwn7WdhOYb8I2yXsV2G7hf0m7HdhfwjbI+xPdeok6+/+tqn3Qv/W5Cawztcv0N712PZOHvjnvOWf7m+n/iXy8rewvcL2xfcvpAuLCIsWSMt5IiT/su77m/DtJXz7CJ906L50whchfNEC//418oLIhGmgCTok/QU8tv0btJd8xr2Qvfbna1/wvbLcky5Z3EB71T5wapYebK+E9wQuEmSvrJynedECOFIKk0w355MpSaYZ4iZTWExYXPKTsILCCgkrrBNYBkFqmYQvRvjihK8A4StI+AoRvsIhkOlmIJlmFMCRaSZoL/mMMche+/MVL4Aj0wJAMi0IJNNCQDItbCmZfpNPpiSZFhE3RYUVE1Zc2BHCjhRWQlhJncCKEKRWlPAVI3zFCd8RhO9IwleC8JUMgUy/AZJpESCZFgWSaTEgmRYHkukRQDI9EkimJYBkWtJSMt2ST6YkmZYSN6WFlRFWVthRwsoJKy+sgk5gpQhSK034yhC+soTvKMJXjvCVJ3wVQiDTLUAyLQUk09JAMi0DJNOyQDI9Ckim5YBkWh5IphUK8JBSaa0P/jPORJ6wm7wjPU/PnMjLXsPS85i/7Nz3ujM9z7XokNtew9MPoq7Z/nuNSD8ojGT57XVX+kHiLfu/97o7/aCxm/1fe41MP4Q+qEfvdU/6IfVUPWqvUYe2V/26nf691+j0Q+71f/2C3phD3+tfvHFvkL00Prsv2F45eHZs0L08/D8uHfe+dH867v1yfDrufXwCYK9/vpQxHad7HkjneV86Tv3peeZaAZ45qe1Vu7Zz6Hulp/2rFslD3SuSRtQ1cWh7RdNIjCQOZa8Meq9k/U4Hv1dm2n9it97B7hVL8+mD7IPbK+63V73anQ5mrwJpufRn7bzvVTAt116vk9e9CqXlgTfyqO0K52WvPGq7InnbK0/armhe98qDtiuW971y1XbFD2avXLTdEQe3l6+2O/Jg9/LRdiUOfq//1HYlD2Wv/9B2pdJw2q70Ie5Fabsyh77Xv7Rd2SB7adruqGB75Zyhg+7l0Xbl0xAaav9eFdIwekzudXQaTtsdA9jL1XYV03Da7sGQtF0i2JV8KB2nE//1KzYBdCLxKzaHrBPJX7E5RJ34H79ic0g68b9+xeZQdKLPr9gctE70/RWbg9SJ0QI4nZjrbx0chE7Mw28d5Fkn5um3DvKoE/P4Wwd50ol5/q2DPOjEg/itg1x14kH91kEuOrHwwZ0T++rEg/4g1kcnHsIHsf+pEw/pg9j/0ImH+EEsqRMP9YNYSicG+CD2XzqR64PYoDqxFPCzltLAz4AM+2zqH514FGgvqRPLAfZydWJ5ps+T9H/1OegzH5uG04mTgGeoyM/j/vebnGqvB9IP5PJ/v7aucirX5TmaPP9Sv2L/v8+w5fmOPJeR5ynyHESeX8hzB3leIOd8OZ/LuVrOw3KOlfOnnBvlvCfnNDlfyblIzjNyDpHzg8z5ccKOF1ZJ2AnCKgs7UVgVYVWFnSTsZGHVhFUXVkPYKcJqCjtV5kSYPHTNkrkWVltYHWHynxzPFiZ/e6G+sAbCThPWUNjpwhoJO0PVvLGwJsLOEna2sHOENRV2rrDzhJ0vrJmwC4RdKOwiYc2FXSzsEmGXCmsh7DJhlwu7QlhLYVcKu0rY1cJaCWstrI2wa4S1FXatsOuEtRPWXlgHYY6wjsI6Cess7HphXYR1FdZNWHdhPYT1FNZL2A3CegvrI6yvsH7C+gsbIGygsBuF3SRskLCbhQ0WdouwIcJuFXabsNuFDRV2h7Bhwu4UNlzYCGF3Cbtb2Ehh9wgbJWy0sDHC7hV2n7CxwsYJu1/YeGEThE0U9oCwB4U9JGySsMnCHhY2RdhUYY8Ie1TYY8KmCXtc2HRhM4TNFDZL2BPCnhQ2W9hTwp4W9oywOcKeFfacsOeFzRX2grAXhb0kbJ6wl4W9IuxVYfOFvSbsdWFvpO3/B0QWCntT2FvCFgl7W9hiYe8IWyLsXWHvCXtf2FJhy4QtF/aBsBXCPhT2kbCPha0U9omwVcI+FbZa2Bphnwn7XNhaYV8IWyfsS2HrhX0l7GthG4RtFLZJ2GZh3wjbIuxbYd8J+17YVmHbhP0g7Edh24XtEPaTsJ+F7RT2i7Bdwn4VtlvYb8J+F/aHsD3C/hT2l7C/he0Vtk+YbP50YRFhUWEZwjKFxYTFhRUQVlBYIWGFhRURVlRYMWHFhR0h7EhhJYSVFFZKWGlhZYSVFXaUsHLCygurIOxoYccIqyjsWGHHCTteWCVhJwirLOxEYVWEVRV2krCThVUTVl1YDWGnCKsp7FRhktTkByVZwmoJqy2sjrC6wrKF1RNWX1gDYacJayjsdGGNhJ0heVpYY2Hye5/PEna2sHOENRV2rrDzhJ0vrJmwC4RdKOwiYc2FXSzsEmGXCmsh7DJhlwu7QlhLYVcKu0rY1cJaCWstrI2wa4S1FXatsOuEtRMmvyuqgzBHWEdhnYR1Fna9sC7CugrrJqy7sB7CegrrJewGYb2F9RHWV1g/Yf2FDRA2UNiNwm4SNkjYzcIGC7tF2BBhtwq7TdjtwoYKk79TIX8XQv4Og/zdA/k7A/KzfvkZvfxsXX4mLj/Llp9By8+O5We+8rNa+Rmr/GxUfqYpP4uUnyHKz/7cy/ueI8965DnKJPXs7jVd3Zfe3Lhc76WzzknzXDN91p72WZvjs/a6z9oCn7XFPmtLfNZW+ayt9llb57O23mftB5+17T5ru3zWdvusZUT+ey3ms1bEZ62Yz9rRPmsVfdYq+6xV8Vmr7bNW12etoc9aI5+1C33WmvusXe6z1tJnzfFZ6+Sz1t1nrafP2mCftSE+a8N81ob7rI33WZvos/awz9pUn7Wnfdbm+Ky96LM2z2dtsc/aEp+15T5rK3zW1vmsrfdZ2+yztsVnbZfP2m6ftb981vb68VL0v9eK+ayV8lkr47NW2Wetis9aDZ+1mj5rDX3WGvmsne2z1tRn7XKftZY+a2181tr6rHX3Wevps9bPZ22Az9o6n7X1Pmubfda2+Kzt8lnb7bP2l8/aXp+1Ihn/vVbMZ62Uz1oZn7XKPmtVfNZq+KzV9Flr6LPWyGftbJ+1pj5rl/ustfRZa+Oz1tZnrbvPWk+ftX4+awN81ob5rA33WRvlszbGZ+1hn7WpPmvTfdZm+qy96LM2z2ftdZ+1BT5ry33WVvisrfJZW+2zttlnbYvP2g8+a9t91v7yWdvrs5aR+d9rMZ+1Uj5rZXzWjvZZq+izVsNnrabPWm2ftbo+a2f7rDX1WbvQZ625z1obn7W2PmuOz1onn7V+PmsDfNYG+6wN8Vkb5bM2xmdtvM/aRJ+16T5rM33WnvZZm+Oz9rrP2gKftcU+a0t81lb5rK32WVvns7beZ+0Hn7XtPmu7fNZ2+6xlxP57LeazVsRnrZjP2tE+axV91ir7rFXxWavts1bXZ62hz1ojn7ULfdaa+6xd7rPW0mfN8Vnr5LPW3Wetp8/aYJ+1IT5rw3zWhvusjfdZm+iz9rDP2lSftad91ub4rL3oszbPZ22xz9oSn7XlPmsrfNbW+ayt91nb7LO2xWdtl8/abp+1v3zW9vrxUvy/14r5rJXyWSvjs1bZZ62Kz1oNn7WaPmsNfdYa+ayd7bPW1Gftcp+1lj5rbXzW2vqsdfdZ6+mz1s9nbYDP2jCfteE+a6N81sb4rD3sszbVZ226z9pMn7UXfdbm+ay97rO2wGdtuc/aCp+1VT5rq33WNvusbfFZ+8FnbbvP2l8+a3t91jIK/PdazGetlM9aGZ+1o33WKvqs1fBZq+mzVttnra7P2tk+a0191i70WWvus9bGZ62tz5rjs9bJZ62fz9oAn7XBPmtDfNZG+ayN8Vkb77M20Wdtus/aTJ+1p33W5visve6ztsBnbbHP2hKftVU+a6t91tb5rK33WfvBZ227z9oun7XdPmsZBf97LeazVsRnrZjP2tE+axV91ir7rFXxWavts1bXZ62hz1ojn7ULfdaa+6xd7rPW0mfN8Vnr5LPW3Wetp8/aYJ+1IT5rw3zWhvusjfdZm+iz9rDP2lSftad91ub4rL3oszbPZ22xz9oSn7XlPmsrfNbW+ayt91nb7LO2xa/Hivz3Wj2ftUY+a2f6rDX3WbvEZ62lz9pVPmudfNau91nr6bN2w3+sub9Lruj8n3+zq5D6M139nTPV60SwK8vdvzDP/ol42r+vQp77wtqa+jWIf35Pz3ul/8friPan39/V/V5fUWLN3bOk+tMbr/scBbU/S3v2BeYy6e5fimd/slalPfeltOf05vtMUAzufm4fZKb9+4poa//VM+n4+JJ6LFHiZ7mXi5lSHp+bzyO1WDM9+yBr6u4f49n/H0zGefavRWHS69Mx4K1DuhaT3qfgWNulE/FFtZ+px+j9OxTnRbTX+rf5RvPwdylsumtHEPHp/38FiVi9PhdbFH/qdXF7NPM/9op71r1/P679Xa4aliRicmP/P2icUILuoQkA","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"61":{"source":"use keccak256::keccak256;\n\nglobal MAX_SIGNERS: u32 = 3;\n\npub fn main(\n    message_hash: [u8; 32], \n    operation_signature: [u8; 65],\n    identity_verification_signature: [u8; 65],\n    identity_pub_x: [u8; 32],\n    identity_pub_y: [u8; 32],\n    operation_pub_x: [u8; 32],\n    operation_pub_y: [u8; 32],\n    signers_identifiers: [u8; 32 * MAX_SIGNERS],\n    threshold: u32, \n    contract_address: [u8; 20]\n) -> pub (Field, Field, Field, Field) {\n    // --------------------IDENTITY VERIFICATION-------------------- // \n    // verify the identity signature is valid\n    let identity_verification_signature_message_hash = keccak256(\n        bytes_to_hex_string(contract_address),\n        40\n    );\n    let mut identity_sig_64: [u8; 64] = [0; 64];\n    for i in 0..64 {\n        identity_sig_64[i] = identity_verification_signature[i];\n    }\n    \n    assert(std::ecdsa_secp256k1::verify_signature(\n        identity_pub_x,\n        identity_pub_y, \n        identity_sig_64, \n        identity_verification_signature_message_hash\n    ));\n\n\n    let hashed_verification_signature = keccak256(signature_to_hex_string(identity_verification_signature), 130);\n\n    let mut is_valid = false;\n    for i in 0..MAX_SIGNERS {\n        if i < threshold {\n            let start_idx = i * 32;\n            let mut matches = true;\n            for j in 0..32 {\n                if hashed_verification_signature[j] != signers_identifiers[start_idx + j] {\n                    matches = false;\n                }\n            }\n            if matches {\n                is_valid = true;\n            }\n        }\n    }\n    //assert(is_valid, \"Verification signature does not match any authorized signer\");\n\n    // --------------------PAYLOAD SIGNATURE VERIFICATION-------------------- // \n\n    let mut operation_sig_64: [u8; 64] = [0; 64];\n    for i in 0..64 {\n        operation_sig_64[i] = operation_signature[i];\n    }\n    \n    //assert(std::ecdsa_secp256k1::verify_signature(operation_pub_x, operation_pub_y, operation_sig_64, message_hash));\n\n    let signer_identifiers_hash = hash_signer_identifiers(signers_identifiers, 3);\n\n    let message_hash_field_31_bytes = field_from_bytes_32_trunc(message_hash);\n    let signer_identifiers_hash_field_31_bytes = field_from_bytes_32_trunc(signer_identifiers_hash);\n\n    // Concatenate last bytes of both hashes\n    let message_hash_last_byte = message_hash[31] as Field;\n    let signer_identifier_hash_last_byte = signer_identifiers_hash[31] as Field;\n    // Multiply by 256 to shift left by 8 bits (equivalent to << 8)\n    let last_bytes_field = (message_hash_last_byte * 256) + signer_identifier_hash_last_byte;\n\n\n    (\n        address_to_field(contract_address),\n        message_hash_field_31_bytes,\n        signer_identifiers_hash_field_31_bytes,  \n        last_bytes_field\n    )\n}\n\n\n\nfn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n\n\n\nfn bytes_to_field(bytes: [u8; 32]) -> Field {\n    let mut result: Field = 0;\n    \n    // Convert bytes to field\n    for i in 0..32 {\n        result = result * 256 + (bytes[i] as Field);\n    }\n    \n    result\n}\n\n\nfn address_to_field(bytes: [u8; 20]) -> Field {\n    let mut result: Field = 0;\n    \n    // Convert bytes to field\n    for i in 0..20 {\n        result = result * 256 + (bytes[i] as Field);\n    }\n    \n    result\n}\n\nfn nibble_to_ascii(nibble: u8) -> u8 {\n    if nibble < 10 {\n        nibble + 48  // '0' to '9'\n    } else {\n        nibble + 87  // 'a' to 'f'\n    }\n}\n\n// Function to convert hex bytes to ASCII string representation\nfn signature_bytes_to_ascii(hex_bytes: [u8; 65]) -> [u8; 132] {\n    let mut result: [u8; 132] = [0; 132];\n    \n    // Add \"0x\" prefix\n    result[0] = 48;  // '0'\n    result[1] = 120; // 'x'\n    \n    // Convert each byte to two ASCII characters\n    for i in 0..65 {\n        let byte = hex_bytes[i];\n        let high_nibble = byte >> 4;\n        let low_nibble = byte & 0x0f;\n        \n        result[2 + i * 2] = nibble_to_ascii(high_nibble);\n        result[2 + i * 2 + 1] = nibble_to_ascii(low_nibble);\n    }\n    \n    result\n}\n\nfn address_bytes_to_ascii(address_bytes: [u8; 20]) -> [u8; 42] {\n    let mut result: [u8; 42] = [0; 42]; // 0x + 40 hex chars\n    \n    // Add \"0x\" prefix\n    result[0] = 48;  // '0'\n    result[1] = 120; // 'x'\n    \n    // Convert each byte to two ASCII characters\n    for i in 0..20 {\n        let byte = address_bytes[i];\n        let high_nibble = byte >> 4;\n        let low_nibble = byte & 0x0f;\n        \n        // Convert high nibble to hex\n        result[2 + i * 2] = if high_nibble < 10 {\n            high_nibble + 48 // '0' to '9'\n        } else {\n            high_nibble + 87 // 'a' to 'f'\n        };\n        \n        // Convert low nibble to hex\n        result[2 + i * 2 + 1] = if low_nibble < 10 {\n            low_nibble + 48 // '0' to '9'\n        } else {\n            low_nibble + 87 // 'a' to 'f'\n        };\n    }\n    \n    result\n}\n\nfn create_ethereum_signed_message_hash(message: [u8], message_len: u32) -> [u8; 32] {\n    // Create the Ethereum Signed Message prefix\n    let prefix: [u8; 26] = [\n        25, 69, 116, 104, 101, 114, 101, 117, 109, 32, 83, 105, 103, 110, 101, 100, 32, 77, 101, 115, 115, 97, 103, 101, 58, 10\n    ];\n    \n    // Convert message length to ASCII string\n    let mut length_str: [u8; 2] = [0; 2];\n    let tens = message_len / 10;\n    let ones = message_len % 10;\n    length_str[0] = 48 + tens as u8; // Convert to ASCII\n    length_str[1] = 48 + ones as u8; // Convert to ASCII\n    \n    // Calculate total length\n    let total_len = 26 + 2 + message_len as u32;\n    let mut full_message: [u8; 100] = [0; 100]; // Using a larger buffer to be safe\n    \n    // Copy prefix\n    for i in 0..26 {\n        full_message[i] = prefix[i];\n    }\n    \n    // Copy length string\n    for i in 0..2 {\n        full_message[26 + i] = length_str[i];\n    }\n    \n    // Copy message\n    for i in 0..message_len {\n        full_message[28 + i] = message[i];\n    }\n    \n    // Hash the full message\n    keccak256(full_message, total_len)\n}\n\n#[test]\nfn test_hex_literal_hashing() {\n    // The actual hex string bytes for \"5b38da6a701c568545dcfcb03fcb875f56beddc4\" (without 0x)\n    let address_str: [u8; 40] = [\n        53, 98, 51, 56, 100, 97, 54, 97, 55, 48, 49, 99, 53, 54, 56, 53, 52, 53, 100, 99, 102, 99, 98, 48, 51, 102, 99, 98, 56, 55, 53, 102, 53, 54, 98, 101, 100, 100, 99, 52\n    ];\n\n    // Create the Ethereum Signed Message prefix\n    let prefix: [u8; 26] = [\n        25, 69, 116, 104, 101, 114, 101, 117, 109, 32, 83, 105, 103, 110, 101, 100, 32, 77, 101, 115, 115, 97, 103, 101, 58, 10\n    ];\n    \n    // Create the length string \"40\" (length of address string)\n    let length_str: [u8; 2] = [52, 48]; // \"40\" in ASCII\n    \n    // Concatenate everything: prefix + length_str + address_str\n    let mut full_message: [u8; 68] = [0; 68];\n    \n    // Copy prefix\n    for i in 0..26 {\n        full_message[i] = prefix[i];\n    }\n    \n    // Copy length string\n    for i in 0..2 {\n        full_message[26 + i] = length_str[i];\n    }\n    \n    // Copy address string\n    for i in 0..40 {\n        full_message[28 + i] = address_str[i];\n    }\n\n    // Print the full message bytes\n    println(\"Full message bytes:\");\n    println(full_message);\n\n    // Hash the full message\n    println(\"Hash from full message:\");\n    let hash = keccak256(full_message, 68);\n    println(hash);\n\n   \n}\n\n#[test]\nfn test_ecdsa_verification() {\n    // Test data from previous test\n    let message_hash: [u8; 32] = [\n        0xd6, 0x84, 0x40, 0x8e, 0x8b, 0x17, 0xdb, 0xfe, 0x4a, 0x8c, 0x84, 0x45, 0x78, 0xcd, 0x25, 0xad, 0x8f, 0xd8, 0xe8, 0xd3, 0xb2, 0x07, 0x62, 0x30, 0x6d, 0x2c, 0x50, 0x0e, 0x47, 0xea, 0xc7, 0x94\n    ];\n\n    // Signature: c0781763e94934afd8ae233236034b93cf948a5b80eb28c520e82cec11f2bbe426ec03f31eccf5ade14cd2b18660a95d38d78f3a8008fac8f50d9f16287eafd61b\n    let signature: [u8; 65] = [\n        0x4b, 0x24, 0x8b, 0x7c, 0x58, 0x02, 0x1b, 0x70, 0x4e, 0x95, 0x4b, 0x32, 0x5f, 0xc5, 0x77, 0x61, 0xf2, 0xdf, 0xf5, 0x6c, 0x70, 0x3d, 0x9f, 0x0b, 0xef, 0x57, 0xc9, 0xb5, 0x51, 0x21, 0xf0, 0xb3, 0x52, 0x7b, 0xd7, 0xc7, 0x26, 0x63, 0x46, 0x9d, 0xcf, 0xa7, 0x17, 0xab, 0x9e, 0x32, 0x07, 0xf1, 0xce, 0xfe, 0x7a, 0xf7, 0x02, 0xaa, 0xd6, 0x88, 0xa6, 0x18, 0xf2, 0x96, 0x5e, 0x41, 0x23, 0xd1, 0x1b\n    ];\n       \n    let mut sig_64: [u8; 64] = [0; 64];\n    for i in 0..64 {\n        sig_64[i] = signature[i];\n    }\n\n    let pub_x: [u8; 32] = [\n        0x99, 0x3b, 0x0b, 0x69, 0x2b, 0xfc, 0x19, 0xfe, 0x81, 0xf5, 0x5c, 0x5f, 0x08, 0xec, 0x75, 0x21, 0xf3, 0x23, 0x5a, 0x46, 0xe0, 0xae, 0xc9, 0x6b, 0xe6, 0x09, 0xd5, 0x64, 0x75, 0x23, 0xf2, 0x51\n    ];\n\n    let pub_y: [u8; 32] = [\n        0x1e, 0x34, 0xdc, 0x79, 0x0f, 0x9b, 0x92, 0x6a, 0xf7, 0x25, 0x22, 0x02, 0x9b, 0x0f, 0xea, 0x06, 0xb9, 0x90, 0x37, 0xaf, 0x0e, 0x5d, 0x01, 0x53, 0xa4, 0x9e, 0xc3, 0x2b, 0xa4, 0x1b, 0xf5, 0x76\n    ];\n\n    // Verify the signature\n    let is_valid = std::ecdsa_secp256k1::verify_signature(pub_x, pub_y, sig_64, message_hash);\n    assert(is_valid);\n}\n\n\n\n\n\n\n\n// Unconstrained function to convert u64 to ASCII bytes\nunconstrained fn u64_to_ascii_bytes(value: u64) -> [u8; 20] {\n    let mut result: [u8; 20] = [0; 20];\n    let mut temp = value;\n    let mut pos = 19;\n    \n    // Handle zero case\n    if value == 0 {\n        result[19] = 48; // '0'\n    } else {\n        // Convert each digit to ASCII\n        while temp > 0 {\n            let digit = (temp % 10) as u8;\n            result[pos] = digit + 48; // Convert to ASCII\n            temp = temp / 10;\n            if pos > 0 {\n                pos -= 1;\n            }\n        }\n    }\n    \n    // Shift all digits to the right\n    let mut shifted: [u8; 20] = [0; 20];\n    let mut count = 0;\n    for i in 0..20 {\n        if result[i] != 0 {\n            count += 1;\n        }\n    }\n    \n    for i in 0..count {\n        shifted[20 - count + i] = result[20 - count + i];\n    }\n    \n    shifted\n}\n\n// Function to hash a u64 value using Keccak256\nfn hash_u64(value: u64) -> [u8; 32] {\n    // Convert value to ASCII bytes using unconstrained function\n    let digits = unsafe { u64_to_ascii_bytes(value) };\n    \n    // Count non-zero digits\n    let mut digit_count = 0;\n    for i in 0..20 {\n        if digits[i] != 0 {\n            digit_count += 1;\n        }\n    }\n    \n    // Copy digits to message\n    let mut message: [u8; 64] = [0; 64];\n    for i in 0..20 {\n        if i < digit_count {\n            message[i] = digits[20 - digit_count + i];\n        }\n    }\n    \n    // Hash the digits\n    keccak256(message, digit_count)\n}\n\n\n#[test]\nfn test_main(){\n    let message_hash: [u8; 32] = [77, 212, 132, 20, 51, 9, 215, 117, 228, 178, 114, 1, 37, 153, 113, 152, 27, 190, 145, 23, 105, 100, 103, 77, 167, 99, 173, 20, 76, 190, 79, 118 ];\n\n    let operation_signature: [u8; 65] = [\n        0x72, 0x92, 0x73, 0x9b, 0x11, 0x39, 0x4a, 0x5f, 0x9a, 0x0b, 0x82, 0x53, 0x49, 0x42, 0x89, 0x24, 0x98, 0xa3, 0xf9, 0xe7, 0x3d, 0xb5, 0x02, 0x08, 0x22, 0x21, 0xb1, 0xc1, 0x6f, 0x13, 0xfa, 0x77, 0x51, 0xe5, 0xc1, 0xa4, 0x21, 0xd4, 0x33, 0xd2, 0x87, 0xe1, 0xb0, 0xe5, 0xaa, 0xa5, 0x75, 0xda, 0x4d, 0xb1, 0xd9, 0x47, 0xfa, 0xfe, 0xc1, 0xbd, 0x8c, 0x4e, 0x00, 0xe8, 0x32, 0x8b, 0x8f, 0x6e, 0x1b\n    ];\n    \n    let identity_verification_signature: [u8; 65] = [\n        0x4b, 0x24, 0x8b, 0x7c, 0x58, 0x02, 0x1b, 0x70, 0x4e, 0x95, 0x4b, 0x32, 0x5f, 0xc5, 0x77, 0x61, 0xf2, 0xdf, 0xf5, 0x6c, 0x70, 0x3d, 0x9f, 0x0b, 0xef, 0x57, 0xc9, 0xb5, 0x51, 0x21, 0xf0, 0xb3, 0x52, 0x7b, 0xd7, 0xc7, 0x26, 0x63, 0x46, 0x9d, 0xcf, 0xa7, 0x17, 0xab, 0x9e, 0x32, 0x07, 0xf1, 0xce, 0xfe, 0x7a, 0xf7, 0x02, 0xaa, 0xd6, 0x88, 0xa6, 0x18, 0xf2, 0x96, 0x5e, 0x41, 0x23, 0xd1, 0x1b\n    ];\n\n    let identity_pub_x: [u8; 32] = [\n        0x99, 0x3b, 0x0b, 0x69, 0x2b, 0xfc, 0x19, 0xfe, 0x81, 0xf5, 0x5c, 0x5f, 0x08, 0xec, 0x75, 0x21, 0xf3, 0x23, 0x5a, 0x46, 0xe0, 0xae, 0xc9, 0x6b, 0xe6, 0x09, 0xd5, 0x64, 0x75, 0x23, 0xf2, 0x51\n    ];\n    \n    let identity_pub_y: [u8; 32] = [\n        0x1e, 0x34, 0xdc, 0x79, 0x0f, 0x9b, 0x92, 0x6a, 0xf7, 0x25, 0x22, 0x02, 0x9b, 0x0f, 0xea, 0x06, 0xb9, 0x90, 0x37, 0xaf, 0x0e, 0x5d, 0x01, 0x53, 0xa4, 0x9e, 0xc3, 0x2b, 0xa4, 0x1b, 0xf5, 0x76\n    ];\n\n    let operation_pub_x: [u8; 32] = [\n        0x91, 0x42, 0x77, 0xce, 0x9a, 0xaf, 0xf1, 0xa9, 0x63, 0x53, 0x9c, 0x5b, 0xcc, 0x28, 0xc9, 0xc7, 0x11, 0x62, 0xb0, 0xe0, 0xf7, 0x1f, 0x01, 0xd7, 0xd5, 0x1f, 0x86, 0x08, 0x2a, 0x30, 0x85, 0x34\n    ];\n    \n    let operation_pub_y: [u8; 32] = [\n        0xaf, 0xa6, 0xd0, 0x75, 0xd0, 0x39, 0xf6, 0x65, 0xbd, 0x33, 0x70, 0xf5, 0x8d, 0x9d, 0x3d, 0x68, 0xdb, 0xb9, 0x11, 0xb4, 0x6d, 0xe4, 0x2d, 0x66, 0x21, 0xce, 0xa4, 0x0c, 0x21, 0x0a, 0xe2, 0x77\n    ];\n\n    let signers_identifiers: [u8; 32 * MAX_SIGNERS] = [\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42,\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42,\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42\n    ];\n\n    let threshold: u32 = 2;\n\n    let contract_address: [u8; 20] = [\n        0xf4, 0x79, 0x3b, 0x68, 0x88, 0x37, 0x33, 0x92, 0x2f, 0x04, 0xcd, 0xb8, 0xe5, 0xe4, 0xf2, 0xcf, 0x83, 0x9d, 0xbf, 0xfa\n    ];\n\n\n\n    let (field_contract_address,  message_hash_field_31_bytes, signer_identifiers_hash_field_31_bytes,  last_bytes_field) = main(\n        message_hash,\n        operation_signature,\n        identity_verification_signature,\n        identity_pub_x,\n        identity_pub_y,\n        operation_pub_x,\n        operation_pub_y,\n        signers_identifiers,\n        threshold,\n        contract_address\n    );\n\n    println(\"Field contract address:\");\n    println(field_contract_address);\n\n    println(\"Message hash field 31 bytes:\");\n    println(message_hash_field_31_bytes);\n    \n    println(\"Signer identifiers hash field 31 bytes:\");\n    println(signer_identifiers_hash_field_31_bytes);\n\n    println(\"Last bytes:\");\n    println(last_bytes_field);\n}\n\n#[test] \nfn test_identity_hash(){\n    let contract_address: [u8; 20] = [\n        0x5b, 0x38, 0xda, 0x6a, 0x70, 0x1c, 0x56, 0x85, 0x45, 0xdc, 0xfc, 0xb0, 0x3f, 0xcb, 0x87, 0x5f, 0x56, 0xbe, 0xdd, 0xc4\n    ];\n    \n    let address_hex = bytes_to_hex_string(contract_address);\n    let identity_hash = keccak256(address_hex, 40);\n    println(\"Identity hash:\");\n    println(identity_hash);\n}\n\n// Helper function to convert bytes to hex string\nfn bytes_to_hex_string(bytes: [u8; 20]) -> [u8; 40] {\n    let mut hex_string: [u8; 40] = [0; 40];\n    for i in 0..20 {\n        let byte = bytes[i];\n        let high = byte >> 4;\n        let low = byte & 0x0f;\n        \n        // Convert high nibble to hex\n        if high < 10 {\n            hex_string[i * 2] = high + 48; // '0' to '9'\n        } else {\n            hex_string[i * 2] = high + 87; // 'a' to 'f'\n        }\n        \n        // Convert low nibble to hex\n        if low < 10 {\n            hex_string[i * 2 + 1] = low + 48; // '0' to '9'\n        } else {\n            hex_string[i * 2 + 1] = low + 87; // 'a' to 'f'\n        }\n    }\n    hex_string\n}\n\n// Helper function to convert signature bytes to hex string\nfn signature_to_hex_string(signature: [u8; 65]) -> [u8; 130] {\n    let mut hex_string: [u8; 130] = [0; 130];\n    for i in 0..65 {  // Use all 65 bytes\n        let byte = signature[i];\n        let high = byte >> 4;\n        let low = byte & 0x0f;\n        \n        // Convert high nibble to hex\n        if high < 10 {\n            hex_string[i * 2] = high + 48; // '0' to '9'\n        } else {\n            hex_string[i * 2] = high + 87; // 'a' to 'f'\n        }\n        \n        // Convert low nibble to hex\n        if low < 10 {\n            hex_string[i * 2 + 1] = low + 48; // '0' to '9'\n        } else {\n            hex_string[i * 2 + 1] = low + 87; // 'a' to 'f'\n        }\n    }\n    hex_string\n}\n\n#[test]\nfn test_signature_bytes_to_ascii(){\n    let signature_bytes: [u8; 65] = [\n        0xc0, 0x78, 0x17, 0x63, 0xe9, 0x49, 0x34, 0xaf, 0xd8, 0xae, 0x23, 0x32, 0x36, 0x03, 0x4b, 0x93, 0xcf, 0x94, 0x8a, 0x5b, 0x80, 0xeb, 0x28, 0xc5, 0x20, 0xe8, 0x2c, 0xec, 0x11, 0xf2, 0xbb, 0xe4, 0x26, 0xec, 0x03, 0xf3, 0x1e, 0xcc, 0xf5, 0xad, 0xe1, 0x4c, 0xd2, 0xb1, 0x86, 0x60, 0xa9, 0x5d, 0x38, 0xd7, 0x8f, 0x3a, 0x80, 0x08, 0xfa, 0xc8, 0xf5, 0x0d, 0x9f, 0x16, 0x28, 0x7e, 0xaf, 0xd6, 0x1b\n    ];\n    \n    let signature_hex = signature_to_hex_string(signature_bytes);\n    let signature_hash = keccak256(signature_hex, 130);\n    println(\"Signature hash:\");\n    println(signature_hash);\n}\n\n// Helper function to hash signer identifiers\nfn hash_signer_identifiers(signers: [u8; 32 * MAX_SIGNERS], num_signers: u32) -> [u8; 32] {\n    // Convert to hex string\n    let mut identifier_hex: [u8; 64 * MAX_SIGNERS] = [0; 64 * MAX_SIGNERS];\n    for i in 0..MAX_SIGNERS {\n        if i < num_signers {\n            let byte = signers[i * 32];\n            let high = byte >> 4;\n            let low = byte & 0x0f;\n            \n            // Convert high nibble to hex\n            if high < 10 {\n                identifier_hex[i * 64] = high + 48; // '0' to '9'\n            } else {\n                identifier_hex[i * 64] = high + 87; // 'a' to 'f'\n            }\n            \n            // Convert low nibble to hex\n            if low < 10 {\n                identifier_hex[i * 64 + 1] = low + 48; // '0' to '9'\n            } else {\n                identifier_hex[i * 64 + 1] = low + 87; // 'a' to 'f'\n            }\n        }\n    }\n\n    keccak256(identifier_hex, 64 * num_signers)\n}\n\n#[test]\nfn test_signer_identifier_hash(){\n    let signer_identifier: [u8; 32 * MAX_SIGNERS] = [\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42,\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42,\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42\n    ];\n\n    let identifier_hash = hash_signer_identifiers(signer_identifier, 3);\n    println(\"Signer identifier hash:\");\n    println(identifier_hash);\n}\n\n#[test]\nfn test_contract_address_hash() {\n    let contract_address: [u8; 20] = [\n        0xf4, 0x79, 0x3b, 0x68, 0x88, 0x37, 0x33, 0x92, 0x2f, 0x04, 0xcd, 0xb8, 0xe5, 0xe4, 0xf2, 0xcf, 0x83, 0x9d, 0xbf, 0xfa\n    ];\n    \n    let address_hex = bytes_to_hex_string(contract_address);\n    let identity_hash = keccak256(address_hex, 40);\n    \n    println(\"Contract address hex:\");\n    println(address_hex);\n    \n    println(\"Identity hash:\");\n    println(identity_hash);\n}","path":"/home/drone/projects/multisig-circuits/ecdsa_signer/src/main.nr"},"62":{"source":"\r\nuse std::runtime::is_unconstrained;\r\nuse std::hash::keccak::keccakf1600;\r\n\r\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\r\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\r\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\r\nglobal NUM_KECCAK_LANES: u32 = 25;\r\n\r\n#[no_predicates]\r\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\r\n    assert(N >= message_size);\r\n\r\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\r\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\r\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\r\n    if is_unconstrained() {\r\n        for i in 0..message_size {\r\n            block_bytes[i] = input[i];\r\n        }\r\n    } else {\r\n        for i in 0..N {\r\n            if i < message_size {\r\n                block_bytes[i] = input[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    //1. format_input_lanes\r\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\r\n    //maximum number of bytes to hash\r\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\r\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\r\n\r\n    block_bytes[message_size] = 1;\r\n    block_bytes[real_blocks_bytes - 1] = 0x80;\r\n\r\n    // populate a vector of 64-bit limbs from our byte array\r\n    let mut sliced_buffer =\r\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\r\n    for i in 0..sliced_buffer.len() {\r\n        let limb_start = WORD_SIZE * i;\r\n\r\n        let mut sliced = 0;\r\n        let mut v = 1;\r\n        for k in 0..WORD_SIZE {\r\n            sliced += v * (block_bytes[limb_start + k] as Field);\r\n            v *= 256;\r\n        }\r\n\r\n        sliced_buffer[i] = sliced as u64;\r\n    }\r\n\r\n    //2. sponge_absorb\r\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\r\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\r\n    // thus allowing us to simplify the loop body.\r\n    if is_unconstrained() {\r\n        for i in 0..real_max_blocks {\r\n            if (i == 0) {\r\n                for j in 0..LIMBS_PER_BLOCK {\r\n                    state[j] = sliced_buffer[j];\r\n                }\r\n            } else {\r\n                for j in 0..LIMBS_PER_BLOCK {\r\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\r\n                }\r\n            }\r\n            state = keccakf1600(state);\r\n        }\r\n    } else {\r\n        // `real_max_blocks` is guaranteed to at least be `1`\r\n        // We peel out the first block as to avoid a conditional inside of the loop.\r\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\r\n        for j in 0..LIMBS_PER_BLOCK {\r\n            state[j] = sliced_buffer[j];\r\n        }\r\n        state = keccakf1600(state);\r\n        for i in 1..max_blocks {\r\n            if i < real_max_blocks {\r\n                for j in 0..LIMBS_PER_BLOCK {\r\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\r\n                }\r\n                state = keccakf1600(state);\r\n            }\r\n        }\r\n    }\r\n\r\n    //3. sponge_squeeze\r\n    let mut result = [0; 32];\r\n    for i in 0..4 {\r\n        let lane = state[i] as Field;\r\n        let lane_le: [u8; 8] = lane.to_le_bytes();\r\n        for j in 0..8 {\r\n            result[8 * i + j] = lane_le[j];\r\n        }\r\n    }\r\n    result\r\n}","path":"/home/drone/projects/multisig-circuits/ecdsa_signer/lib/keccak256/src/keccak256.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert","directive_to_radix"]}