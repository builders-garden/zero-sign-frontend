{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":8766902412886712300,"abi":{"parameters":[{"name":"message_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"operation_signature","type":{"kind":"array","length":65,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"identity_verification_signature","type":{"kind":"array","length":65,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"identity_pub_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"identity_pub_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"operation_pub_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"operation_pub_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signers_identifiers","type":{"kind":"array","length":96,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"threshold","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"contract_address","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13452066450966815008":{"error_kind":"string","string":"Verification signature does not match any authorized signer"}}},"bytecode":"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","debug_symbols":"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1fKi1fKi1fKi1fKi1fKi1fKi1fKi1fKi1fKi1fKi1fKi9QUv+q9bi/UFL3p11Wldla2rWrPR8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8qLV8aJzdLzo4yprXeWtq2brqtW6areuitZVp3VVtq5qzYa1ZsNas2Gt2bDWbFhrNqw1G9aaDWvNhrVmw1qz4a3Z8NZseGs2vDUb3poNb82Gt2bDW7Phrdnw1mzM1mzM1mzM1mzM1mzM1mzM1mzM1mzM1mzM1mzM1mys1mys1mys1mys1mys1mys1mys1mys1mys1mys1mzs1mzs1mzs1mzs1mzs1mzs1mzs1mzs1mzs1mzs1mxEazaiNRvRmo1ozUa0ZiNasxGt2YjWbERrNqI1G6c1G6c1G6c1G6c1G6c1G6c1G6c1G6c1G6c1G6c1G9majWzNRrZmI1uzka3ZyNZsZGs2sjUb2ZqNbM1GtWajWrNRrdmo1mxUazaqNRvVmo1qzUa1ZqPlRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRa3lRe0LXvRfNiQfV63WVbt1VbSuas1Gy4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4tay4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6y4t6qy/qrb6ot/qi3uqLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLesuLzpYXnS0vOltedLa86Gx50dnyorPlRWfLi86WF50tLzpbXnS2vOhsedHZ8qKz5UVny4vOlhedLS86W150trzobHnR+QUvumt+uCqGvbzq9dnIyt+ueqQ7r7Bm66pXZ+MRs4yPV+X5/KqX/5P3R2Jf+8PPc2Ksl5BNQIKAHAKSN0DC8xNk1ktIAZDXjfHdECMgfgPkmH2EHB8vIZOALAKyCcgdG39ifYKc+RJyCMgdG5/703+ujFf+cxUAWXdsfO36CKk4LyFGQJyATAJyw8bnsI8PrRz+coTXJiA3bHza+AQxewVyCEgCB4lVAGQPAmIExIGDxJ4EZBGQTUACOEjsQ0CSgBQAiQEcicIIiANHopgEZAEHidgEJAjIISAJHImiAMgZwJHoGAFx4CBxJgFZBIQwdyeAg8Q5BIQwd4cwdzmAg0QaASHMXRLmLhdwJMpNQAI4EuUhIAkcJLIASBHmrghzVw4ciWoSkAUciWoTkFvM3aePlfRx+XL/mM3m3J9e7L/d0Xlzd5Rv7o7qjd3RGuPN3ZG9uTvyN3dH883d0Xpzd7Tf3B29tc/sNd7aZ/Yab+0ze40395ltb+4z297cZ7a9uc9se3Of2fbmPrPtzX1m25v7zLY395ltb+4z297cZ7a/uc9sf3Of2f7mPrMd/8z2zPPhvWu8ckf4Z/av/7+T3179619S/fKO9pu7I/wz+9e/CfLjHR17eUf4Z/avTY8Pd/QI6T6/o5cv3mt+uJG9Vnx8seUrLz5lH3ThqXk+f/H//qz5jn7Wej8/6xzv6Ge1d/Sz+jv6Wec7+lnXO/pZ9zv6WeMd/azv6Nw039G5ab6jc9N6R+em9Y7OTesdnZvWOzo33fLtrmf5Wd/RuWm9o3PTekfnpvWOzk3rHZ2b9js6N+13dG7a7+jctN/RuemO78g+zc/6js5N+x2dm/Y7Ojftd3Ru2u/o3BTv6NwU7+jcFO/o3BTv6Nx0x9808DQ/6zs6N8U7OTc9fvPHn7//4Yfv/+s/f/jpT9/+8v1PP/7tcenjH/+/b3/+/ts//vDdb7/9y99//NNn//aX///XD//mw/V//fmnP33357///N2v7/TPf/d4+/8B","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"61":{"source":"use keccak256::keccak256;\n\nglobal MAX_SIGNERS: u32 = 3;\n\npub fn main(\n    message_hash: [u8; 32], \n    operation_signature: [u8; 65],\n    identity_verification_signature: [u8; 65],\n    identity_pub_x: [u8; 32],\n    identity_pub_y: [u8; 32],\n    operation_pub_x: [u8; 32],\n    operation_pub_y: [u8; 32],\n    signers_identifiers: [u8; 32 * MAX_SIGNERS],\n    threshold: u32, \n    contract_address: [u8; 20]\n) -> pub (Field, Field, Field, Field) {\n    // --------------------IDENTITY VERIFICATION-------------------- // \n    // verify the identity signature is valid\n    let identity_verification_signature_message_hash = keccak256(\n        bytes_to_hex_string(contract_address),\n        40\n    );\n\n    let mut identity_sig_64: [u8; 64] = [0; 64];\n    for i in 0..64 {\n        identity_sig_64[i] = identity_verification_signature[i];\n    }\n    \n    assert(std::ecdsa_secp256k1::verify_signature(\n        identity_pub_x,\n        identity_pub_y, \n        identity_sig_64, \n        identity_verification_signature_message_hash\n    ));\n\n\n    let hashed_verification_signature = keccak256(signature_to_hex_string(identity_verification_signature), 130);\n\n    let mut is_valid = false;\n    for i in 0..MAX_SIGNERS {\n        if i < threshold {\n            let start_idx = i * 32;\n            let mut matches = true;\n            for j in 0..32 {\n                if hashed_verification_signature[j] != signers_identifiers[start_idx + j] {\n                    matches = false;\n                }\n            }\n            if matches {\n                is_valid = true;\n            }\n        }\n    }\n    assert(is_valid, \"Verification signature does not match any authorized signer\");\n\n    // --------------------PAYLOAD SIGNATURE VERIFICATION-------------------- // \n\n    let mut operation_sig_64: [u8; 64] = [0; 64];\n    for i in 0..64 {\n        operation_sig_64[i] = operation_signature[i];\n    }\n    \n    assert(std::ecdsa_secp256k1::verify_signature(operation_pub_x, operation_pub_y, operation_sig_64, message_hash));\n\n    let signer_identifiers_hash = hash_signer_identifiers(signers_identifiers, 3);\n\n    let message_hash_field_31_bytes = field_from_bytes_32_trunc(message_hash);\n    let signer_identifiers_hash_field_31_bytes = field_from_bytes_32_trunc(signer_identifiers_hash);\n\n    // Concatenate last bytes of both hashes\n    let message_hash_last_byte = message_hash[31] as Field;\n    let signer_identifier_hash_last_byte = signer_identifiers_hash[31] as Field;\n    // Multiply by 256 to shift left by 8 bits (equivalent to << 8)\n    let last_bytes_field = (message_hash_last_byte * 256) + signer_identifier_hash_last_byte;\n\n\n    (\n        address_to_field(contract_address),\n        message_hash_field_31_bytes,\n        signer_identifiers_hash_field_31_bytes,  \n        last_bytes_field\n    )\n}\n\n\n\nfn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n\n\n\nfn bytes_to_field(bytes: [u8; 32]) -> Field {\n    let mut result: Field = 0;\n    \n    // Convert bytes to field\n    for i in 0..32 {\n        result = result * 256 + (bytes[i] as Field);\n    }\n    \n    result\n}\n\n\nfn address_to_field(bytes: [u8; 20]) -> Field {\n    let mut result: Field = 0;\n    \n    // Convert bytes to field\n    for i in 0..20 {\n        result = result * 256 + (bytes[i] as Field);\n    }\n    \n    result\n}\n\nfn nibble_to_ascii(nibble: u8) -> u8 {\n    if nibble < 10 {\n        nibble + 48  // '0' to '9'\n    } else {\n        nibble + 87  // 'a' to 'f'\n    }\n}\n\n// Function to convert hex bytes to ASCII string representation\nfn signature_bytes_to_ascii(hex_bytes: [u8; 65]) -> [u8; 132] {\n    let mut result: [u8; 132] = [0; 132];\n    \n    // Add \"0x\" prefix\n    result[0] = 48;  // '0'\n    result[1] = 120; // 'x'\n    \n    // Convert each byte to two ASCII characters\n    for i in 0..65 {\n        let byte = hex_bytes[i];\n        let high_nibble = byte >> 4;\n        let low_nibble = byte & 0x0f;\n        \n        result[2 + i * 2] = nibble_to_ascii(high_nibble);\n        result[2 + i * 2 + 1] = nibble_to_ascii(low_nibble);\n    }\n    \n    result\n}\n\nfn address_bytes_to_ascii(address_bytes: [u8; 20]) -> [u8; 42] {\n    let mut result: [u8; 42] = [0; 42]; // 0x + 40 hex chars\n    \n    // Add \"0x\" prefix\n    result[0] = 48;  // '0'\n    result[1] = 120; // 'x'\n    \n    // Convert each byte to two ASCII characters\n    for i in 0..20 {\n        let byte = address_bytes[i];\n        let high_nibble = byte >> 4;\n        let low_nibble = byte & 0x0f;\n        \n        // Convert high nibble to hex\n        result[2 + i * 2] = if high_nibble < 10 {\n            high_nibble + 48 // '0' to '9'\n        } else {\n            high_nibble + 87 // 'a' to 'f'\n        };\n        \n        // Convert low nibble to hex\n        result[2 + i * 2 + 1] = if low_nibble < 10 {\n            low_nibble + 48 // '0' to '9'\n        } else {\n            low_nibble + 87 // 'a' to 'f'\n        };\n    }\n    \n    result\n}\n\nfn create_ethereum_signed_message_hash(message: [u8], message_len: u32) -> [u8; 32] {\n    // Create the Ethereum Signed Message prefix\n    let prefix: [u8; 26] = [\n        25, 69, 116, 104, 101, 114, 101, 117, 109, 32, 83, 105, 103, 110, 101, 100, 32, 77, 101, 115, 115, 97, 103, 101, 58, 10\n    ];\n    \n    // Convert message length to ASCII string\n    let mut length_str: [u8; 2] = [0; 2];\n    let tens = message_len / 10;\n    let ones = message_len % 10;\n    length_str[0] = 48 + tens as u8; // Convert to ASCII\n    length_str[1] = 48 + ones as u8; // Convert to ASCII\n    \n    // Calculate total length\n    let total_len = 26 + 2 + message_len as u32;\n    let mut full_message: [u8; 100] = [0; 100]; // Using a larger buffer to be safe\n    \n    // Copy prefix\n    for i in 0..26 {\n        full_message[i] = prefix[i];\n    }\n    \n    // Copy length string\n    for i in 0..2 {\n        full_message[26 + i] = length_str[i];\n    }\n    \n    // Copy message\n    for i in 0..message_len {\n        full_message[28 + i] = message[i];\n    }\n    \n    // Hash the full message\n    keccak256(full_message, total_len)\n}\n\n#[test]\nfn test_hex_literal_hashing() {\n    // The actual hex string bytes for \"5b38da6a701c568545dcfcb03fcb875f56beddc4\" (without 0x)\n    let address_str: [u8; 40] = [\n        53, 98, 51, 56, 100, 97, 54, 97, 55, 48, 49, 99, 53, 54, 56, 53, 52, 53, 100, 99, 102, 99, 98, 48, 51, 102, 99, 98, 56, 55, 53, 102, 53, 54, 98, 101, 100, 100, 99, 52\n    ];\n\n    // Create the Ethereum Signed Message prefix\n    let prefix: [u8; 26] = [\n        25, 69, 116, 104, 101, 114, 101, 117, 109, 32, 83, 105, 103, 110, 101, 100, 32, 77, 101, 115, 115, 97, 103, 101, 58, 10\n    ];\n    \n    // Create the length string \"40\" (length of address string)\n    let length_str: [u8; 2] = [52, 48]; // \"40\" in ASCII\n    \n    // Concatenate everything: prefix + length_str + address_str\n    let mut full_message: [u8; 68] = [0; 68];\n    \n    // Copy prefix\n    for i in 0..26 {\n        full_message[i] = prefix[i];\n    }\n    \n    // Copy length string\n    for i in 0..2 {\n        full_message[26 + i] = length_str[i];\n    }\n    \n    // Copy address string\n    for i in 0..40 {\n        full_message[28 + i] = address_str[i];\n    }\n\n    // Print the full message bytes\n    println(\"Full message bytes:\");\n    println(full_message);\n\n    // Hash the full message\n    println(\"Hash from full message:\");\n    let hash = keccak256(full_message, 68);\n    println(hash);\n\n   \n}\n\n#[test]\nfn test_ecdsa_verification() {\n    // Test data from previous test\n    let message_hash: [u8; 32] = [\n        0x6c, 0xf3, 0xc1, 0xc3, 0xe4, 0x05, 0xa2, 0x13, 0x73, 0x4d, 0x31, 0xbe, 0x4d, 0x4e, 0xed, 0x85, 0x3b, 0x03, 0x02, 0xa3, 0x83, 0x42, 0x7e, 0x0b, 0xe1, 0x5b, 0xe2, 0x31, 0x08, 0xb2, 0x37, 0x02\n    ];\n\n    // Signature: c0781763e94934afd8ae233236034b93cf948a5b80eb28c520e82cec11f2bbe426ec03f31eccf5ade14cd2b18660a95d38d78f3a8008fac8f50d9f16287eafd61b\n    let signature: [u8; 65] = [\n        0xc0, 0x78, 0x17, 0x63, 0xe9, 0x49, 0x34, 0xaf, 0xd8, 0xae, 0x23, 0x32, 0x36, 0x03, 0x4b, 0x93, 0xcf, 0x94, 0x8a, 0x5b, 0x80, 0xeb, 0x28, 0xc5, 0x20, 0xe8, 0x2c, 0xec, 0x11, 0xf2, 0xbb, 0xe4, 0x26, 0xec, 0x03, 0xf3, 0x1e, 0xcc, 0xf5, 0xad, 0xe1, 0x4c, 0xd2, 0xb1, 0x86, 0x60, 0xa9, 0x5d, 0x38, 0xd7, 0x8f, 0x3a, 0x80, 0x08, 0xfa, 0xc8, 0xf5, 0x0d, 0x9f, 0x16, 0x28, 0x7e, 0xaf, 0xd6, 0x1b\n    ];\n       \n    let mut sig_64: [u8; 64] = [0; 64];\n    for i in 0..64 {\n        sig_64[i] = signature[i];\n    }\n\n    let pub_x: [u8; 32] = [\n        0x32, 0x08, 0x25, 0x63, 0xc6, 0x93, 0x61, 0xcf, 0xe9, 0x74, 0xc7, 0xb6, 0x99, 0x6a, 0x14, 0x92, 0x17, 0xd9, 0xb4, 0x38, 0xb0, 0x4b, 0x94, 0x0a, 0x53, 0x0a, 0xd1, 0xbc, 0x23, 0x43, 0x37, 0xcc\n    ];\n\n    let pub_y: [u8; 32] = [\n        0x6a, 0x85, 0x02, 0x04, 0x8a, 0x03, 0x54, 0x28, 0x3f, 0xa1, 0xdb, 0x34, 0x64, 0x47, 0x83, 0x05, 0x2b, 0xdd, 0xc2, 0x6a, 0x5e, 0xce, 0x0d, 0x38, 0x77, 0xfb, 0x8d, 0xa1, 0xad, 0xc4, 0x4a, 0x5f\n    ];\n\n    // Verify the signature\n    let is_valid = std::ecdsa_secp256k1::verify_signature(pub_x, pub_y, sig_64, message_hash);\n    assert(is_valid);\n}\n\n\n\n\n\n\n\n// Unconstrained function to convert u64 to ASCII bytes\nunconstrained fn u64_to_ascii_bytes(value: u64) -> [u8; 20] {\n    let mut result: [u8; 20] = [0; 20];\n    let mut temp = value;\n    let mut pos = 19;\n    \n    // Handle zero case\n    if value == 0 {\n        result[19] = 48; // '0'\n    } else {\n        // Convert each digit to ASCII\n        while temp > 0 {\n            let digit = (temp % 10) as u8;\n            result[pos] = digit + 48; // Convert to ASCII\n            temp = temp / 10;\n            if pos > 0 {\n                pos -= 1;\n            }\n        }\n    }\n    \n    // Shift all digits to the right\n    let mut shifted: [u8; 20] = [0; 20];\n    let mut count = 0;\n    for i in 0..20 {\n        if result[i] != 0 {\n            count += 1;\n        }\n    }\n    \n    for i in 0..count {\n        shifted[20 - count + i] = result[20 - count + i];\n    }\n    \n    shifted\n}\n\n// Function to hash a u64 value using Keccak256\nfn hash_u64(value: u64) -> [u8; 32] {\n    // Convert value to ASCII bytes using unconstrained function\n    let digits = unsafe { u64_to_ascii_bytes(value) };\n    \n    // Count non-zero digits\n    let mut digit_count = 0;\n    for i in 0..20 {\n        if digits[i] != 0 {\n            digit_count += 1;\n        }\n    }\n    \n    // Copy digits to message\n    let mut message: [u8; 64] = [0; 64];\n    for i in 0..20 {\n        if i < digit_count {\n            message[i] = digits[20 - digit_count + i];\n        }\n    }\n    \n    // Hash the digits\n    keccak256(message, digit_count)\n}\n\n\n#[test]\nfn test_main(){\n    let message_hash: [u8; 32] = [\n        0x6c, 0xf3, 0xc1, 0xc3, 0xe4, 0x05, 0xa2, 0x13, 0x73, 0x4d, 0x31, 0xbe, 0x4d, 0x4e, 0xed, 0x85, 0x3b, 0x03, 0x02, 0xa3, 0x83, 0x42, 0x7e, 0x0b, 0xe1, 0x5b, 0xe2, 0x31, 0x08, 0xb2, 0x37, 0x02\n    ];\n\n    let operation_signature: [u8; 65] = [\n        0xc0, 0x78, 0x17, 0x63, 0xe9, 0x49, 0x34, 0xaf, 0xd8, 0xae, 0x23, 0x32, 0x36, 0x03, 0x4b, 0x93, 0xcf, 0x94, 0x8a, 0x5b, 0x80, 0xeb, 0x28, 0xc5, 0x20, 0xe8, 0x2c, 0xec, 0x11, 0xf2, 0xbb, 0xe4, 0x26, 0xec, 0x03, 0xf3, 0x1e, 0xcc, 0xf5, 0xad, 0xe1, 0x4c, 0xd2, 0xb1, 0x86, 0x60, 0xa9, 0x5d, 0x38, 0xd7, 0x8f, 0x3a, 0x80, 0x08, 0xfa, 0xc8, 0xf5, 0x0d, 0x9f, 0x16, 0x28, 0x7e, 0xaf, 0xd6, 0x1b\n    ];\n    \n    let identity_verification_signature: [u8; 65] = [\n        0xc0, 0x78, 0x17, 0x63, 0xe9, 0x49, 0x34, 0xaf, 0xd8, 0xae, 0x23, 0x32, 0x36, 0x03, 0x4b, 0x93, 0xcf, 0x94, 0x8a, 0x5b, 0x80, 0xeb, 0x28, 0xc5, 0x20, 0xe8, 0x2c, 0xec, 0x11, 0xf2, 0xbb, 0xe4, 0x26, 0xec, 0x03, 0xf3, 0x1e, 0xcc, 0xf5, 0xad, 0xe1, 0x4c, 0xd2, 0xb1, 0x86, 0x60, 0xa9, 0x5d, 0x38, 0xd7, 0x8f, 0x3a, 0x80, 0x08, 0xfa, 0xc8, 0xf5, 0x0d, 0x9f, 0x16, 0x28, 0x7e, 0xaf, 0xd6, 0x1b\n    ];\n\n    let identity_pub_x: [u8; 32] = [\n        0x32, 0x08, 0x25, 0x63, 0xc6, 0x93, 0x61, 0xcf, 0xe9, 0x74, 0xc7, 0xb6, 0x99, 0x6a, 0x14, 0x92, 0x17, 0xd9, 0xb4, 0x38, 0xb0, 0x4b, 0x94, 0x0a, 0x53, 0x0a, 0xd1, 0xbc, 0x23, 0x43, 0x37, 0xcc\n    ];\n    \n    let identity_pub_y: [u8; 32] = [\n        0x6a, 0x85, 0x02, 0x04, 0x8a, 0x03, 0x54, 0x28, 0x3f, 0xa1, 0xdb, 0x34, 0x64, 0x47, 0x83, 0x05, 0x2b, 0xdd, 0xc2, 0x6a, 0x5e, 0xce, 0x0d, 0x38, 0x77, 0xfb, 0x8d, 0xa1, 0xad, 0xc4, 0x4a, 0x5f\n    ];\n\n    let operation_pub_x: [u8; 32] = [\n        0x32, 0x08, 0x25, 0x63, 0xc6, 0x93, 0x61, 0xcf, 0xe9, 0x74, 0xc7, 0xb6, 0x99, 0x6a, 0x14, 0x92, 0x17, 0xd9, 0xb4, 0x38, 0xb0, 0x4b, 0x94, 0x0a, 0x53, 0x0a, 0xd1, 0xbc, 0x23, 0x43, 0x37, 0xcc\n    ];\n    \n    let operation_pub_y: [u8; 32] = [\n        0x6a, 0x85, 0x02, 0x04, 0x8a, 0x03, 0x54, 0x28, 0x3f, 0xa1, 0xdb, 0x34, 0x64, 0x47, 0x83, 0x05, 0x2b, 0xdd, 0xc2, 0x6a, 0x5e, 0xce, 0x0d, 0x38, 0x77, 0xfb, 0x8d, 0xa1, 0xad, 0xc4, 0x4a, 0x5f\n    ];\n\n    let signers_identifiers: [u8; 32 * MAX_SIGNERS] = [\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42,\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42,\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42\n    ];\n\n    let threshold: u32 = 1;\n\n    let contract_address: [u8; 20] = [\n        0x5b, 0x38, 0xda, 0x6a, 0x70, 0x1c, 0x56, 0x85, 0x45, 0xdc, 0xfc, 0xb0, 0x3f, 0xcb, 0x87, 0x5f, 0x56, 0xbe, 0xdd, 0xc4\n    ];\n\n\n\n    let (field_contract_address,  message_hash_field_31_bytes, signer_identifiers_hash_field_31_bytes,  last_bytes_field) = main(\n        message_hash,\n        operation_signature,\n        identity_verification_signature,\n        identity_pub_x,\n        identity_pub_y,\n        operation_pub_x,\n        operation_pub_y,\n        signers_identifiers,\n        threshold,\n        contract_address\n    );\n\n    println(\"Field contract address:\");\n    println(field_contract_address);\n\n    println(\"Message hash field 31 bytes:\");\n    println(message_hash_field_31_bytes);\n    \n    println(\"Signer identifiers hash field 31 bytes:\");\n    println(signer_identifiers_hash_field_31_bytes);\n\n    println(\"Last bytes:\");\n    println(last_bytes_field);\n}\n\n#[test] \nfn test_identity_hash(){\n    let contract_address: [u8; 20] = [\n        0x5b, 0x38, 0xda, 0x6a, 0x70, 0x1c, 0x56, 0x85, 0x45, 0xdc, 0xfc, 0xb0, 0x3f, 0xcb, 0x87, 0x5f, 0x56, 0xbe, 0xdd, 0xc4\n    ];\n    \n    let address_hex = bytes_to_hex_string(contract_address);\n    let identity_hash = keccak256(address_hex, 40);\n    println(\"Identity hash:\");\n    println(identity_hash);\n}\n\n// Helper function to convert bytes to hex string\nfn bytes_to_hex_string(bytes: [u8; 20]) -> [u8; 40] {\n    let mut hex_string: [u8; 40] = [0; 40];\n    for i in 0..20 {\n        let byte = bytes[i];\n        let high = byte >> 4;\n        let low = byte & 0x0f;\n        \n        // Convert high nibble to hex\n        if high < 10 {\n            hex_string[i * 2] = high + 48; // '0' to '9'\n        } else {\n            hex_string[i * 2] = high + 87; // 'a' to 'f'\n        }\n        \n        // Convert low nibble to hex\n        if low < 10 {\n            hex_string[i * 2 + 1] = low + 48; // '0' to '9'\n        } else {\n            hex_string[i * 2 + 1] = low + 87; // 'a' to 'f'\n        }\n    }\n    hex_string\n}\n\n// Helper function to convert signature bytes to hex string\nfn signature_to_hex_string(signature: [u8; 65]) -> [u8; 130] {\n    let mut hex_string: [u8; 130] = [0; 130];\n    for i in 0..65 {  // Use all 65 bytes\n        let byte = signature[i];\n        let high = byte >> 4;\n        let low = byte & 0x0f;\n        \n        // Convert high nibble to hex\n        if high < 10 {\n            hex_string[i * 2] = high + 48; // '0' to '9'\n        } else {\n            hex_string[i * 2] = high + 87; // 'a' to 'f'\n        }\n        \n        // Convert low nibble to hex\n        if low < 10 {\n            hex_string[i * 2 + 1] = low + 48; // '0' to '9'\n        } else {\n            hex_string[i * 2 + 1] = low + 87; // 'a' to 'f'\n        }\n    }\n    hex_string\n}\n\n#[test]\nfn test_signature_bytes_to_ascii(){\n    let signature_bytes: [u8; 65] = [\n        0xc0, 0x78, 0x17, 0x63, 0xe9, 0x49, 0x34, 0xaf, 0xd8, 0xae, 0x23, 0x32, 0x36, 0x03, 0x4b, 0x93, 0xcf, 0x94, 0x8a, 0x5b, 0x80, 0xeb, 0x28, 0xc5, 0x20, 0xe8, 0x2c, 0xec, 0x11, 0xf2, 0xbb, 0xe4, 0x26, 0xec, 0x03, 0xf3, 0x1e, 0xcc, 0xf5, 0xad, 0xe1, 0x4c, 0xd2, 0xb1, 0x86, 0x60, 0xa9, 0x5d, 0x38, 0xd7, 0x8f, 0x3a, 0x80, 0x08, 0xfa, 0xc8, 0xf5, 0x0d, 0x9f, 0x16, 0x28, 0x7e, 0xaf, 0xd6, 0x1b\n    ];\n    \n    let signature_hex = signature_to_hex_string(signature_bytes);\n    let signature_hash = keccak256(signature_hex, 130);\n    println(\"Signature hash:\");\n    println(signature_hash);\n}\n\n// Helper function to hash signer identifiers\nfn hash_signer_identifiers(signers: [u8; 32 * MAX_SIGNERS], num_signers: u32) -> [u8; 32] {\n    // Convert to hex string\n    let mut identifier_hex: [u8; 64 * MAX_SIGNERS] = [0; 64 * MAX_SIGNERS];\n    for i in 0..MAX_SIGNERS {\n        if i < num_signers {\n            let byte = signers[i * 32];\n            let high = byte >> 4;\n            let low = byte & 0x0f;\n            \n            // Convert high nibble to hex\n            if high < 10 {\n                identifier_hex[i * 64] = high + 48; // '0' to '9'\n            } else {\n                identifier_hex[i * 64] = high + 87; // 'a' to 'f'\n            }\n            \n            // Convert low nibble to hex\n            if low < 10 {\n                identifier_hex[i * 64 + 1] = low + 48; // '0' to '9'\n            } else {\n                identifier_hex[i * 64 + 1] = low + 87; // 'a' to 'f'\n            }\n        }\n    }\n\n    keccak256(identifier_hex, 64 * num_signers)\n}\n\n#[test]\nfn test_signer_identifier_hash(){\n    let signer_identifier: [u8; 32 * MAX_SIGNERS] = [\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42,\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42,\n        0xae, 0x33, 0xed, 0x35, 0xde, 0x75, 0x38, 0x0f, 0x90, 0x7e, 0x2c, 0x5b, 0x84, 0x36, 0x21, 0x5e, 0x50, 0x3e, 0x7b, 0x91, 0x95, 0x25, 0x07, 0x18, 0xab, 0xfc, 0x62, 0x75, 0x93, 0x56, 0x1f, 0x42\n    ];\n\n    let identifier_hash = hash_signer_identifiers(signer_identifier, 3);\n    println(\"Signer identifier hash:\");\n    println(identifier_hash);\n}","path":"/home/drone/projects/multisig-circuits/ecdsa_signer/src/main.nr"},"62":{"source":"\r\nuse std::runtime::is_unconstrained;\r\nuse std::hash::keccak::keccakf1600;\r\n\r\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\r\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\r\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\r\nglobal NUM_KECCAK_LANES: u32 = 25;\r\n\r\n#[no_predicates]\r\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\r\n    assert(N >= message_size);\r\n\r\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\r\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\r\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\r\n    if is_unconstrained() {\r\n        for i in 0..message_size {\r\n            block_bytes[i] = input[i];\r\n        }\r\n    } else {\r\n        for i in 0..N {\r\n            if i < message_size {\r\n                block_bytes[i] = input[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    //1. format_input_lanes\r\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\r\n    //maximum number of bytes to hash\r\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\r\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\r\n\r\n    block_bytes[message_size] = 1;\r\n    block_bytes[real_blocks_bytes - 1] = 0x80;\r\n\r\n    // populate a vector of 64-bit limbs from our byte array\r\n    let mut sliced_buffer =\r\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\r\n    for i in 0..sliced_buffer.len() {\r\n        let limb_start = WORD_SIZE * i;\r\n\r\n        let mut sliced = 0;\r\n        let mut v = 1;\r\n        for k in 0..WORD_SIZE {\r\n            sliced += v * (block_bytes[limb_start + k] as Field);\r\n            v *= 256;\r\n        }\r\n\r\n        sliced_buffer[i] = sliced as u64;\r\n    }\r\n\r\n    //2. sponge_absorb\r\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\r\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\r\n    // thus allowing us to simplify the loop body.\r\n    if is_unconstrained() {\r\n        for i in 0..real_max_blocks {\r\n            if (i == 0) {\r\n                for j in 0..LIMBS_PER_BLOCK {\r\n                    state[j] = sliced_buffer[j];\r\n                }\r\n            } else {\r\n                for j in 0..LIMBS_PER_BLOCK {\r\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\r\n                }\r\n            }\r\n            state = keccakf1600(state);\r\n        }\r\n    } else {\r\n        // `real_max_blocks` is guaranteed to at least be `1`\r\n        // We peel out the first block as to avoid a conditional inside of the loop.\r\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\r\n        for j in 0..LIMBS_PER_BLOCK {\r\n            state[j] = sliced_buffer[j];\r\n        }\r\n        state = keccakf1600(state);\r\n        for i in 1..max_blocks {\r\n            if i < real_max_blocks {\r\n                for j in 0..LIMBS_PER_BLOCK {\r\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\r\n                }\r\n                state = keccakf1600(state);\r\n            }\r\n        }\r\n    }\r\n\r\n    //3. sponge_squeeze\r\n    let mut result = [0; 32];\r\n    for i in 0..4 {\r\n        let lane = state[i] as Field;\r\n        let lane_le: [u8; 8] = lane.to_le_bytes();\r\n        for j in 0..8 {\r\n            result[8 * i + j] = lane_le[j];\r\n        }\r\n    }\r\n    result\r\n}","path":"/home/drone/projects/multisig-circuits/ecdsa_signer/lib/keccak256/src/keccak256.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert","directive_to_radix"]}